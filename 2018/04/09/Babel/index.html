<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author Name,name@example.com"><title>Babel生态 · Cara's Blog</title><meta name="description" content="对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 presets 以及 trans"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/avator.jpg" style="width:127px;"><h3 title=""><a href="/">Cara's Blog</a></h3><div class="description"><p>咸鱼的学习📒 Lok'tar</p></div></div></div><ul class="social-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="http://github.com/Caraws"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Babel生态</a></h3></div><div class="post-content"><p>对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 presets 以及 transform-runtime 和 babel-polyfill 的区别, 所以总结一下.</p>
<h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h3><p>我理解为 babel 的 command 全家桶, 用于在命令行操作的. 里面包含了 <code>babel</code>/ <code>babel-external-helpers</code>/ <code>babel-node</code> 3个命令</p>
<ul>
<li>babel: 用于编译代码</li>
<li>babel-external-helpers: 用于生成一些 halper 函数, 包含 babel 所有的 hepler 函数 (如: toArray 函数, jsx 转化函数). 这些函数实在 babel transform 的时候用, 都放在 <code>babel-helpers</code> 这个包中, 当这些 helpers 被用到就会被放置在生成代码的顶部. 但是当多个文件都用到了 helpers 函数就会产生冗余代码, 所以 babel 提供这个命令生成一个包含所有 helpers 的 js 文件用于直接引用.(然后可以通过 plugin 去检查全局时候存在这个模块, 存在就不定义)</li>
<li>babel-node: 主要是实现在 node 中写代码和执行脚本的能力, 可以直接运行 ES6代码. 比如直接在 node 中写 jsx, 通过这个就可以执行. 但是要把它编译成可执行的脚本还需要 <code>babel-register</code></li>
</ul>
<p>安装<br><code>npm install --global babel-cli</code></p>
<p>用法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">babel example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 转码结果写入文件</span><br><span class="line">babel example.js -o result.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 整个目录转码</span><br><span class="line">babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成 source map 文件</span><br><span class="line">babel src -d lib -s</span><br></pre></td></tr></table></figure></p>
<p>全局环境下 babel 无法支持不同版本的 babel, 所以安全的做法还是把 babel 装在项目中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure></p>
<p>package.json 改成:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"babel src -d lib"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>babel-register</strong><br>它的特点就是实时编译, 不会输出文件, 用来改写 <code>require</code> 命令为它加上钩子. <code>require</code> 进来的文件就会被转码, 但是它不会转码当前文件中的代码.</p>
<p>安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-register</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先加载 register</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>)</span><br><span class="line"><span class="comment">// 然后 register 就会对 test.js 文件转码</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'test.js'</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于 <code>babel-register</code> 是即时转码, 所以只适用于开发环境使用.</p>
</blockquote>
<h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p><code>babel-core</code> 可以说是 babel 最为核心的一个包, 可以把它看成一个编译器, babel 核心的 API 都在里面. 比如: transform 处理转码, 因为 ES6 的语法跟老语法不同, 所以先将我们的代码转换为 AST(抽象语法树), 然后分别做处理转化为 ES5. webpack 的 babel-loader 就是调用这些 API 完成转译的. <a href="https://babeljs.cn/docs/usage/api/" target="_blank" rel="noopener">这里是详细的 API</a></p>
<blockquote>
<p>这里需要注意的是: <code>babel-core</code> 仅关注 code transform, 也就是说它只做语法上的转换, 比如箭头函数. 所以并不是什么都能用 babel 来转换的, 如果涉及到新的 API 就需要你用 polyfill 来转译, 比如 <code>Promise</code>.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整块引入</span></span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line"><span class="comment">// 也可以选择某个 API 单独使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; transform &#125; <span class="keyword">from</span> <span class="string">'babel-core'</span></span><br></pre></td></tr></table></figure>
<p>主要的 API:</p>
<p><strong>babel.transform(code: string, options?: Object)</strong><br>将传入的 code 做转换, 返回值为一个对象, 参数为: 生成的对象, source map 和 AST</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = babel.transform(<span class="string">"code();"</span>, options);</span><br><span class="line">result.code</span><br><span class="line">result.map</span><br><span class="line">result.ast</span><br></pre></td></tr></table></figure>
<p><strong>babel.transformFile(filename: string, options?: Object, callback: Function)</strong><br>异步转译文件中的所有内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result <span class="comment">// &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>babel.transformFileSync(filename: string, options?: Object)</strong><br><code>babel.transformFile</code> 的同步版本, 返回值为 <code>filename</code> 文件中转译后的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFileSync(filename, options) <span class="comment">// &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>babel.transformFromAst(ast: Object, code?: string, options?: Object)</strong><br>反转译, 给一个 AST 转为 code</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">'if (true) return'</span></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code, &#123; <span class="attr">allowReturnOutsideFunction</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; code, map, ast &#125; = babel.transformFormAst(ast, code, options)</span><br></pre></td></tr></table></figure>
<h3 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h3><p><a href="https://babeljs.cn/docs/plugins/transform-runtime/" target="_blank" rel="noopener"><code>babel-runtime</code></a> 这个包其实就是把 core-js 和 regenerator 组合起来供使用, 它和 <code>babel-polyfill</code> 的都是为了模拟 ES6 环境. 之前提到的 <code>babel-core</code> 只对语法进行转换, 但不支持 Promise, Set, Map, array.reduce, Array.form, genertor, async 这些新 API 的编译, 所以才会用到这两个东西.</p>
<p><strong>core-js</strong>: 主要实现了 Promise, Symbols, ES7提案等等的 polyfill, 包含了大部分的 JavaScript 最新标准的垫片.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要单个引用后再使用</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/array/reduce'</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>regenerator</strong>: 主要实现 generator/yeild, async/await (不知道为啥 core-js 不把这两个一起实现了…)</p>
<p><strong>helpers</strong>: <code>babel-runtime</code> 里也有 helpers, 它里面的 helpers 相当于之前提到的 <code>babel-external-helpers</code> 生成的 helpers.js, 只不过把每个 helpers 函数都单独放到一个文件夹里而已. 这样配合 transform 的时候, 需要用到 helpers 函数就可以直接从 <code>babel-runtime</code> 中引用了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _asyncToGenerator2 = <span class="built_in">require</span>(<span class="string">'babel-runtime/helpers/asyncToGenerator'</span>)</span><br></pre></td></tr></table></figure></p>
<p>区别: </p>
<ul>
<li><a href="https://babeljs.cn/docs/usage/polyfill" target="_blank" rel="noopener">babel-polyfill</a>: 是通过全局对象和内置对象的 prototype 上添加方法来达到目的, 所以一旦引入 <code>babel-polyfill</code> 就会污染全局环境.</li>
<li>babel-runtime: <code>babel-runtime</code> 是一个模块, 所以它不会污染全局环境和内置对象的原型. 它的做法引入需要的 helper 函数(类似: <code>const Promise = require(&#39;babel-runtime/core-js/promise&#39;)</code> 来引入 Promise).</li>
</ul>
<p>优缺点:</p>
<ul>
<li>babel-poly-fill: 引入一劳永逸, 但是污染环境.</li>
<li>babel-runtime: <ol>
<li>手动引入不方便</li>
<li>直接在代码中引入 helper 函数意味着不能共享, 最终打包出来会有很多冗余代码(引入的都是全量的 polyfill). </li>
</ol>
</li>
</ul>
<p>所以要配合 <code>babel-plugin-transform-runtime</code> (很多地方都是把 <code>babel-runtime</code> 和 <code>babel-plugin-transform-runtime</code> 统称为 transform-runtime, 因为它俩得合在一起才好用) 来达到按需引入 helper 避免重复打包和手动引入的痛苦, 它主要是做一层映射: 将 <code>babel-runtime</code> 内引用到的 core-js 或 regenerator.js 映射到具体对应的 helper. </p>
<blockquote>
<p>注意: <code>babel-runtime</code> 无法转码实例方法, 即内置对象原型上的方法, 只能通过 <code>babel-polyfill</code> 来转码. 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.find()</span><br><span class="line"><span class="string">'hello'</span>.includes(<span class="string">'h'</span>)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>另外, 关于为什么 <code>babel-runtime</code> 是 dependencies 依赖, 因为他只是集合了 polyfill 的一个 library, 对应需要的 polyfill 都是要引入项目中, 并跟项目代码一起打包的.</p>
<h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h3><p>它能根据当前的运行环境, 自动确定你需要的 plugins 和 polyfills, babel 的配置官方推荐是写到 <code>.babelrc</code> 文件中, 以 <code>Vue-cli</code> 的 babel 配置为例.<a href="https://babeljs.cn/docs/plugins/preset-env/" target="_blank" rel="noopener">详细参数设置及说明</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, </span><br><span class="line">      &#123; </span><br><span class="line">        "modules": false // 设置 ES6 模块转译的模式, 默认是 commonjs</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 需要支持到哪个阶段的 JavaScript 版本</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  // 需要的插件</span><br><span class="line">  "plugins": [</span><br><span class="line">    "transform-runtime", // 虽然这里没有写 babel-runtime, 但是 transform-runtime 依赖于它, 所以还是要安装</span><br><span class="line">    <span class="string">"transform-vue-jsx"</span></span><br><span class="line">  ],</span><br><span class="line">  // 编译过程是否保留注释</span><br><span class="line">  "comments": false,</span><br><span class="line">  "env": &#123;</span><br><span class="line">    "test": &#123;</span><br><span class="line">      "presets": ["env", "stage-2"],</span><br><span class="line">      "plugins": [ "istanbul"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来 <code>babel-preset-env</code> 中有一个 useBuiltIns 选项(默认值是 false), 就是它实现的根据运行环境并判断需要什么 polyfill, 达到按需引入而不是整个引入, 对于 <code>import &#39;babel-polyfill&#39;</code> 就很棒了. 但是可以看到 vue-template 并没有使用这个选项, 这是因为   <a href="javascript:" title="我消不掉这个超链接😑" target="_blank" rel="noopener">babel-preset-env@1.x</a> 的版本没有办法很好消除未使用的 polyfill, 在2.x 版本下可以用 <code>usebuiltIns: &#39;usage&#39;</code>达到目的.</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>babel 还有很多相关的东西没说到, 只挑了几个最重要的来说, 具体的 helpers/ plugins 都可以到<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">官方仓库</a>查看</p>
<ul>
<li><a href="https://github.com/babel/babel/tree/master/packages/babylon" target="_blank" rel="noopener">badylon</a>: 词法解析器</li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="noopener">babel-traverse</a>: 用于遍历, 维护整个 AST 的状态</li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="noopener">babel-generator</a>: 根据 AST 生成代码</li>
</ul>
<h4 id="babel-的工作流程"><a href="#babel-的工作流程" class="headerlink" title="babel 的工作流程"></a>babel 的工作流程</h4><p>输入需要转码的代码 -&gt; badylon 解析 -&gt; 得到 AST -&gt;<br>babel-traverse 遍历转译 -&gt; 得到新的 AST -&gt;<br>最后 babel-generator 根据新的 AST 生成代码</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个来说我觉得还是 <code>babel-runtime</code> 和 <code>babel-polyfill</code> 比较难区分, 其实两者的核心都在于 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 只是各有优缺点而已, 下面会再简要总结一下区别. 其他的话只需要知道每个东西是干啥的就行了.</p>
<ul>
<li>babel-polyfill: 污染环境, 支持实例方法(如果只想引入一些特定的polyfill, 那就去 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 中找相应的方法自己手动 require 进来); </li>
<li>runtime: 按需引用,不支持实例方法.</li>
</ul>
<p>Created on 2018-4-11 by Cara</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-04-09</span><i class="fa fa-tag"></i><a href="/tags/Babel/" title="Babel" class="tag">Babel </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://yoursite.com/2018/04/09/Babel/,Cara's Blog,Babel生态,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2018/05/06/网络摄像机直播/" title="网络摄像机直播" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2018/04/02/跨域/" title="跨域" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>