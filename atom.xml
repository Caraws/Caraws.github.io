<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cara&#39;s Blog</title>
  
  <subtitle>Do what you like , Like what you do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2022-08-23T10:34:28.757Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Cara</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Algebraic Effects &amp; React</title>
    <link href="https://yoursite.com/2022/08/23/Algebraic-Effects-React/"/>
    <id>https://yoursite.com/2022/08/23/Algebraic-Effects-React/</id>
    <published>2022-08-23T09:54:20.000Z</published>
    <updated>2022-08-23T10:34:28.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几年网上已经有非常的多文章在探讨 React 这次的大手笔, 正好借在 Bench 这段时间里能通过 React18 的源码看看到底做了哪些改变, 主要是对时间切片和调度方面比较感兴趣</p><p>接着就<code>git clone</code> -&gt; <code>setup 源码</code> -&gt; <code>添加beakPoint</code> 一顿操作猛如虎, 然后发现 emmm… 根本无从下手… </p><p>React 的代码量既多, 跳转逻辑又很复杂. 所以果断换思路从设计思想出发, 再到实现. 起码你先知道 React_ _想做什么, 在看咋实现的不容易多了吗(是吗?😒)</p><p>于是打开浏览器 Google: React 的设计思想, 第一个蹦出来的就是今天的主角: <strong>代数效应</strong><br>听上去是个很可怕的名字…</p><blockquote><p>引用一位 React 的核心开发者 <a href="https://github.com/sebmarkbage/" target="_blank" rel="noopener">Sebastian Markbåge</a> 的话<br>React 所做的事就是在践行代数效应</p></blockquote><p>为了更好得理解代数效应, 我们先来看看与之相关的一个东西: CPS </p><h2 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation Passing Style (CPS)"></a>Continuation Passing Style (CPS)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y - x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> result2 = subtract(result1, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> result3 = multiply(result2, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result3) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">x, y, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(y - x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(a * b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, (result1) =&gt; &#123;</span><br><span class="line">  subtract(result1, <span class="number">1</span>, (result2) =&gt; &#123;</span><br><span class="line">    multiply(result2, <span class="number">3</span>, <span class="built_in">console</span>.log) <span class="comment">// 6</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对比之下, 我们可以发现: 好家伙! CPS 不就是我们嗤之以鼻的回调地狱吗! 而且可读性奇差<br>既然这样那我们为什么还要写 CPS 呢? 答案是: 不用写, 但是并不代表 CPS 就是一无是处的. </p><h3 id="抛弃刚刚对-CPS-的有色眼镜-重新观察分析一下-CPS-到底有什么优势"><a href="#抛弃刚刚对-CPS-的有色眼镜-重新观察分析一下-CPS-到底有什么优势" class="headerlink" title="抛弃刚刚对 CPS 的有色眼镜, 重新观察分析一下 CPS 到底有什么优势"></a>抛弃刚刚对 CPS 的有色眼镜, 重新观察分析一下 CPS 到底有什么优势</h3><h4 id="1-Continuation"><a href="#1-Continuation" class="headerlink" title="1. Continuation"></a>1. Continuation</h4><p>在上面的例子中, 每个函数都接收一个<code>next</code>回调函数, 而且每个函数的计算结果都是通过<code>next</code><strong>延续</strong>(细品延续这个词)给下一个函数.<br>顺着这个思路再来看与 CPS 对比的 Direct Style, 它对流程的控制完全取决于我们调用啥. 所以它对延续性(continuation)的控制是隐式的, 不像 CPS 我们一看到<code>next</code>就知道这是要控制流程继续往下延续了. <br>换句话说 CPS 能控制程序后续的流程</p><h4 id="2-同时兼容同步和异步处理"><a href="#2-同时兼容同步和异步处理" class="headerlink" title="2. 同时兼容同步和异步处理"></a>2. 同时兼容同步和异步处理</h4><p>还是利用上面的例子, 假如现在新增一个需求 add 后需要等待 2 秒再执行, 对于 Direct Style 我们必须对 add 后续的整个流程进行调整<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y - x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result2 = subtract(result1, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result3 = multiply(result2, <span class="number">3</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(result3) <span class="comment">// 6</span></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></p><p>对于 CPS 则只需要改变<code>next</code>的调用时机即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">x, y, next</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(next, <span class="number">2000</span>, y - x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(a * b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, (result1) =&gt; &#123;</span><br><span class="line">  subtract(result1, <span class="number">1</span>, (result2) =&gt; &#123;</span><br><span class="line">    multiply(result2, <span class="number">3</span>, <span class="built_in">console</span>.log) <span class="comment">// 6</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以看出这样的改动对于 CPS 来说, 并不需要改动到主流程.</p><h4 id="3-Tail-Call"><a href="#3-Tail-Call" class="headerlink" title="3. Tail Call"></a>3. Tail Call</h4><p>CPS 同时也是尾调用, 只不过 JS 引擎并不支持这种优化, 在此也不展开了</p><p>那么 CPS 对于流程控制有这么强大的力量, 但是又碍于它反人类的书写方式不能使用. 那在 JS 中有没有什么办法能解决这个书写的问题呢?<br><strong>Promise</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">Promise</span>.resolve(x + y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subtract = <span class="function">(<span class="params">x, y</span>) =&gt;</span> delay(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> y - x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Promise</span>.resolve(a * b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">milli</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, milli))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> subtract(res, <span class="number">1</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure></p><p>也许你还想到了 Generator, 没错 Generator / Promise / async/await 都是 CPS 的变形. 如果你再留心一点就会发现 Promise.resolve / Generator.next 其实都是 CPS 中的 next</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一句话 CPS 对流程控制非常牛逼, 不论是同步任务还是异步任务都拿捏的死死的</p><h2 id="Algebraic-Effect"><a href="#Algebraic-Effect" class="headerlink" title="Algebraic Effect"></a>Algebraic Effect</h2><p>前面我们介绍了在 JS 中应用 CPS 的姿势, 但即使这样, 我们在 JS 中使用 CPS 依然很繁琐. </p><blockquote><p>如果你用了 Promise 那么你的控制流都得是 Promise; 如果用Generator 都要包裹在 Generator 中; async/await 也是一样. 就像很多文章中提到的一样, 这些方式都具有”传染性”, 它们会由内到外的层层污染, 那么必然就会给开发者带来大量的心智负担</p></blockquote><p>那有没有更便捷的方式来实现呢, 想想在JS 环境下有哪些能够控制流程的方式呢?<br><code>if</code>/<code>else</code>/ <code>break</code>/<code>throw</code>/<code>switch</code>… 嗯? <code>throw</code>🤔 好像跟其他控制有些不一样, 它可以跳过后续流程(穿透调用栈)! 这似乎有点加强 CPS 那味儿了</p><p>回忆一下: 使用 <code>throw</code>时会在调用处中断, 将 <code>throw</code>后面的语句穿透到最近的 <code>try/catch</code>中从而被捕获.</p><blockquote><p> PS: 虽然规范告诉我们 <code>throw</code>出来的必须是个 <code>Error</code>对象, 但实际 <code>throw</code>可以抛出任意数据类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">taskA</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'throw from taskA'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'never arrive'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am main'</span>)</span><br><span class="line">  taskA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  main()</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'catch: '</span>,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说, 通过<code>throw</code>将执行流程转移至<code>catch</code>代码块, 这就是所谓的<strong> Control Transfer 控制转移</strong></p><p>如果我们把两者结合一下, 试想将 CPS 的<code>next</code>通过<code>throw</code>操作符将控制流转移至 <code>catch</code>中. 这样既解决了 CPS 可读性的问题, 同时也可以避免 “传染”; 除此之外, 还隔离了函数中的副作用. 实际上这”基本上”就是代数效应所蕴含的思想了<br><br>为什么要说是”基本上呢”? 因为这里还有个问题, 那就是在 JS 中<code>throw</code>后就中断了, 不能<strong>延续(或者恢复)当前控制流</strong>(也就是 CPS 中的 Continuation). 所以很多其他文章中都天马行空地造了一些特殊的关键字来尝试解释代数效应, 这里我也使用 <a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noopener">Dan Abramov</a> 在文章的示例稍作修改来完整的展示一下理想中的代数效应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> friendship = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = user.name;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="literal">null</span>) &#123;</span><br><span class="line">      name = perform <span class="string">'ask_name'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeFriends</span>(<span class="params">user1, user2</span>) </span>&#123;</span><br><span class="line">    user1.friendNames = getName(user2);</span><br><span class="line">    user2.friendNames = getName(user1);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user1,</span><br><span class="line">      user2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> arya = &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  <span class="keyword">const</span> gendry = &#123; <span class="attr">name</span>: <span class="string">'Gendry'</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    friendship = makeFriends(arya, gendry);</span><br><span class="line">  &#125; handle (effect) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!user1.friendNames || !user2.friendNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (effect === <span class="string">'ask_name'</span>) &#123;</span><br><span class="line">        resume <span class="keyword">with</span> <span class="string">'Arya Stark'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`friendship: user1: <span class="subst">$&#123;user1.friendNames&#125;</span>; user2: <span class="subst">$&#123;user2.friendNames&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪造 <code>perform</code>关键字替代 <code>throw</code>, 相当于 CPS 中 next 变形(类似于 await), 而 perform 后的语句可以像<code>throw</code>一样被抛出</li><li><code>handle</code>替代<code>catch</code>, 形参<code>effect</code>接收<code>perform</code>关键字传递的实参</li><li>伪造的<code>resume`</code>with`关键字用于恢复当前控制流(getName 中第 4 行), 并回传 ‘Arya Stark’</li><li>恢复后控制流中 name 的值就变成了 ‘Arya Stark’</li></ul><p>所以这段虚构的代码要表达的就是: 对 <code>makeFriends</code>产生的 Effect, 通过 <code>perform</code>由<code>handler</code>处理, 再用<code>resume</code>将结果恢复到函数执行中, 得到新的结果.</p><blockquote><p>之所以要把 CPS 的 next 称作 Continuation, 是希望通过 throw 可以穿透调用栈的特点来获取当前控制流, 所以穿透调用栈(或者说跨调用栈)并不是目的. 而要在 JS 中真正实现获取<strong>当前 Continuation </strong>也就是所谓的 <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="noopener">callcc</a> 也是可以的, 大致是用 CPS + Generator 实现的, 那么就不得不把所有东西都变成 generator 了,在这儿就不展开了有兴趣可以看看这篇文章<a href="https://dev.to/yelouafi/algebraic-effects-in-javascript-part-2---capturing-continuations-with-generators-13da" target="_blank" rel="noopener">capturing-continuations-with-generators</a>.</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>代数效应就是: 利用 CPS 的<strong>流程控制</strong>能力实现对后续流程的控制(perform + resume)结合控制转移能力实现跨调用栈捕获<strong>当前控制流</strong>(try/handle), 改变当前控制流中的 Effect</p><p>在提炼一下代数效应的关键点:</p><ul><li>Effect: 代数所产生的的效应</li><li>Handler: 处理效应的逻辑</li><li>Continuation: 延续流程的控制</li><li>Resume: 恢复 + 与之对应的暂停</li></ul><h2 id="React-amp-Algebraic-Effect"><a href="#React-amp-Algebraic-Effect" class="headerlink" title="React &amp; Algebraic Effect"></a>React &amp; Algebraic Effect</h2><p>前面铺垫了那么多代数效应的知识, 现在我们就试着看看代数效应在 React 中是如何应用的</p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [friendship, makeFriends] = useState(&#123;</span><br><span class="line">    arya: &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">    gendry: &#123; <span class="attr">name</span>: <span class="string">'Gendry'</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arya = friendship.arya</span><br><span class="line">    <span class="keyword">const</span> gendry = friendship.gendry</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!arya.friendNames || !gendry.friendNames) &#123;</span><br><span class="line">      <span class="keyword">const</span> gendryName = getName(gendry)</span><br><span class="line">    <span class="keyword">const</span> aryaName = getName(arya)</span><br><span class="line">      makeFriends(<span class="function">(<span class="params">preUsers</span>) =&gt;</span> (&#123;</span><br><span class="line">        arya: &#123;</span><br><span class="line">          ...preUsers.arya,</span><br><span class="line">          friendNames: gendryName</span><br><span class="line">        &#125;,</span><br><span class="line">        gendry: &#123;</span><br><span class="line">          ...preUsers.gendry,</span><br><span class="line">          friendNames: aryaName</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [friendship])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      friendship:</span><br><span class="line">      user1: &#123;friendship.arya.friendNames&#125;</span><br><span class="line">      user2: &#123;friendship.gendry.friendNames&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到我们只是以 React 的方式改写了上面的示例, 接着再看看改写后是否还满足代数效应的四要素.</p><ul><li>首先<code>friendship</code>的初始值被<code>useState</code>定义, 然后根据<code>getName</code>的返回而被<code>makeFriends</code>修改, 那么我们就可以认为<code>makeFriends</code>是<code>friendship</code>产生 Effect 的一个因素</li><li>而我们选择 <code>useEffect</code>对产生的效应进行处理, 并将<code>friendship</code>作为该 hook 的依赖, 因此可以认为 <code>useEffect</code>就是<code>friendship</code>的处理器了</li></ul><p>接着我们还可以进一步的封装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriends</span>(<span class="params">defaultValue</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> [friendship, makeFriends] = useState(defaultValue)</span><br><span class="line">   </span><br><span class="line">   useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">Object</span>.keys()</span><br><span class="line">       .forEach(<span class="function">(<span class="params">key, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!friendship[key].friendNames) &#123;</span><br><span class="line">           <span class="keyword">const</span> name = getName(friendship[key])</span><br><span class="line">           <span class="keyword">const</span> userKey = index % <span class="number">2</span> === <span class="number">0</span> ? array[index + <span class="number">1</span>] : array[index - <span class="number">1</span>]</span><br><span class="line">           </span><br><span class="line">           makeFriends(<span class="function">(<span class="params">preUsers</span>) =&gt;</span> (&#123;</span><br><span class="line">             ...preUsers,</span><br><span class="line">             [userKey]: &#123;...preUsers[name], <span class="attr">friendNames</span>: name&#125;</span><br><span class="line">            &#125;))</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;, [friendship])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [friendship]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [friendship, makeFriends] = useFriends(&#123;</span><br><span class="line">    arya: &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">    gendry: &#123; <span class="attr">name</span>: <span class="string">'Gendry'</span> &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      friendship:</span><br><span class="line">      user1: &#123;friendship.arya.friendNames&#125;</span><br><span class="line">      user2: &#123;friendship.gendry.friendNames&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这样一来我们的<code>useFriends</code>作为一个具有 Effect 以及处理器的代数, 就可以为任何组件服务了. 不过大家可能注意到了代数效应最酷的<code>resume</code>特性我们并没有看到, 这要如何使用呢?</p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>这就得从 Fiber 说起了, 我们都知道React 从 v16 开始就是 Fiber 架构了. 而 Fiber 架构的本质就是利用浏览器空闲时间, 根据任务的优先级分片执行, 更新过程中可以随时暂停和恢复任务.</p><p>用下图来概括了React 中的调度流程(整个流程都以开启 Concurrent 模式为例)<br><img src="/img/schedule_flow.png" alt="schedule_flow.png"></p><ul><li>更新任务会按照过期时间排序注册在<code>taskQueue</code>队列中(PS:<code>timerQueue</code>保存延时任务, 等时间到了会放入<code>taskQueue</code>)</li><li>然后通过<code>performWorkUntilDeadline</code>调用<code>flushWork</code>执行<code>workLoop</code>来执行队列中的任务<ul><li>执行<code>currentTask.callback</code>(也就是 <code>performConcurrentWorkOnRoot</code>), <strong>如果更新过程中 </strong><code>**shouldYield**</code><strong>为 true 暂停更新</strong></li><li>那么返回的<code>exitState === RootInProgress</code>为true, 导致<code>currentTask.callback</code><strong>返回 </strong><code>**performConcurrentWorkOnRoot**</code><strong>自身</strong></li><li>再回到<code>workLoop</code>拿到<code>currentTask.callback</code>的执行结果<code>continuationCallback</code>也就是<code>performConcurrentWorkOnRoot</code>, 所以<code>if (typeof continuationCallback === &#39;function&#39;)</code>成立. 即保存<code>continuationCallback</code>到<code>currentTask.callback</code>,<strong> 不从</strong><code>**taskQueue**</code><strong>移除当前任务, 下个时间切片重新执行</strong></li></ul></li><li>重复这个过程, 直到队列中的任务执行完毕</li></ul><p>大家可能会说, 内部的调度好像也只看到了暂停, 没有恢复啊. 实际上 JS 有个🔨的<code>resume</code>, 所以 React 直接重新执行一遍函数也就是上面的<code>performConcurrentWorkOnRoot</code>, 虽然不是真正意义上的<code>resume</code>但从效果上来说也达到了恢复的目的, 实现类代数效应.</p><blockquote><p>重新执行 performConcurrentWorkOnRoot 函数 React 同时也做了一些优化, 如果你看过 Fiber 节点中的结构, 会发现内部有一个 memorizedProps(更新结束或暂定时定义) 和 pendingProps(更新开始时定义) 属性. 在函数执行过程中会对比这两个属性, 如果两个属性相等就复用上一次的更新结果, 这就是 React 所说的复用已完成的任务结果.</p></blockquote><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>其实从使用 React hooks 来说, 我们不用关心如何使用代数效应. React 内部已经帮我们处理了 <code>continuation</code>和 <code>resume</code>甚至<code>effect</code>, 而我们只需要专注于<code>handle</code>业务逻辑</p><p>以 useState 为例:<code>const [count, setCount] = useState()</code></p><ul><li>就可以看做<code>perform state()</code>请求 count 的 <code>effect</code></li><li>由 React 中<code>shouldYield</code>暂停 Fiber 更新, 等价于暂停当前函数</li><li>重新执行 <code>continuationCallback</code>等价于 <code>resume</code>恢复执行</li><li>我们需要的业务逻辑<code>handle</code>effect</li></ul><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>React 中的 Suspense 是个更典型的例子, 我们先用官方的例子看看 Suspense 是如何使用的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里内部 throw 了一个 Promise</span></span><br><span class="line"><span class="keyword">const</span> resource = fetchProfileData();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;h1&gt;Loading profile...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ProfileDetails /</span>&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;h1&gt;Loading posts...&lt;<span class="regexp">/h1&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ProfileTimeline /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileDetails</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Try to read user info, although it might not have loaded yet</span></span><br><span class="line">  <span class="keyword">const</span> user = resource.user.read();</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;user.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfileTimeline</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Try to read posts, although they might not have loaded yet</span></span><br><span class="line">  <span class="keyword">const</span> posts = resource.posts.read();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;posts.map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;&#123;post.text&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>子组件异步读取数据, 将数据渲染在组件中</li><li>如果数据未加载完毕, React 会暂停渲染该组件, 转而渲染 <code>fallback</code>组件</li><li>等到数据就绪, 从暂停位置继续渲染子组件</li></ul><p>以代数效应来解读</p><ul><li><code>resource.user.read()</code>内部<code>throw promise</code>等价于 <code>perform resource.user.read()</code></li><li>react 内部<code>catch</code>到<code>thenable</code>的函数放进<code>updateQueue</code>更新队列中,  对应组件会被标记为<code>mode: &#39;hidden&#39;</code>. 相当于暂停了当前函数的执行(PS: 其实这个时候子组件的对应 Fiber 和对应关系已经创建好, 只是放在缓存池了)</li><li>在<code>promise</code>完成后, React 会在 commit 阶段重新调度渲染子组件, 其实就是恢复执行了.  </li></ul><blockquote><p>虽然本质上也不是恢复了函数, 不过在 React 看来这里重新渲染组件和恢复执行没什么区别. 因为在 Suspense 内部不管是 fallback 还是子组件都只会创建一次同时会建立好节点之间的对应关系, 后续 rerender 的时候只是改变了 child 的指针罢了</p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>代数效应本质上就是把”做什么”和”如何做”这两件事儿分离了, 同时提供了对流程控制的能力. React 也是结合了这些特征, 从原来依赖 JS  原生调用栈同步更新方式重构为了现在 Fiber Reconciler 自己模拟了一套组件调用栈/Hooks/Suspense 一系列的新特性. 也印证了 React Hooks 作者的那一句话<code>我们在 React 中所做的事就是在践行代数效应</code></p><blockquote><p>其实出了 React 以外还有其他库也使用了代数效应作为心智模型, 可以思考看看… 或许…也可以自己造个轮子?</p></blockquote><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><ul><li><a href="https://dev.to/yelouafi/algebraic-effects-in-javascript-part-1---continuations-and-control-transfer-3g88" target="_blank" rel="noopener">continuations-and-control-transfer</a></li><li><a href="https://zhuanlan.zhihu.com/p/380855727" target="_blank" rel="noopener">干货｜详解Algebraic Effects代数效应</a></li><li><a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noopener">Algebraic Effects for the Rest of Us</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这几年网上已经有非常的多文章在探讨 React 这次的大手笔, 正好借在 Bench 这段时间里能通过 React18 的源码看看到底做了哪
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="React" scheme="https://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>细说HTTP变化史</title>
    <link href="https://yoursite.com/2022/03/25/%E7%BB%86%E8%AF%B4HTTP%E5%8F%98%E5%8C%96%E5%8F%B2/"/>
    <id>https://yoursite.com/2022/03/25/细说HTTP变化史/</id>
    <published>2022-03-25T03:53:08.000Z</published>
    <updated>2022-08-23T09:37:40.693Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 发展至今已经发生了太多的变化, 平常工作中其实并不会注意这些变化, 甚至说根本不关心… 但在前端的工作中却与它密切相关,从通信到性能优化等等. 下面就来聊聊 HTTP</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>主角 HTTP(超文本传输协议), 它的作用就是利用网络将服务端的超文本信息传输给客户端的一种协议. 建立在 TCP 之上, 所以 HTTP 的优化及瓶颈都是基于 TCP 的特性</p><p>主要的特点:</p><ul><li>简单快速: 客户端想服务器请求时, 只需要发送请求方法和路径即可</li><li>灵活: 支持多种传输格式, 由 Content-Type 控制</li><li>无连接: 每次连接只处理一个请求-响应, 然后断开连接</li><li>无状态: 每个 HTTP 之间都是独立/无关的, 不需要保留状态信息</li></ul><h4 id="HTTP1-x"><a href="#HTTP1-x" class="headerlink" title="HTTP1.x"></a>HTTP1.x</h4><p>HTTP1.x 主要经历两个版本分别是 HTTP1.0 和 HTTP1.1, 而 HTTP1.1 的出现弥补多了很多 1.0 时期的问题.</p><p><strong>多个 TCP 连接</strong><br>1.0 时期每发送一个请求-响应, 都需要重新建立 TCP 连接, 响应完再关闭, 下个请求又要建立再关闭, 所以这是一个非常消耗性能的过程. 这就会带来两个问题:</p><ol><li>每个请求都需要重新建立 TCP 连接</li><li>必须等待前一个请求响应了, 后一个请求才能发送, 也就是熟称的<code>队头阻塞</code></li></ol><p>于是在 1.1 中通过 <code>keep-alive</code> 来避免建立多次 TCP 连接的问题, 在一定时间内复用已经建立的 TCP 连接, 这样在 TCP 连接中可以发送多次请求-响应. </p><p><code>keep-alive</code> 存在的问题: </p><ol><li>每条 TCP 连接中的请求还是阻塞的(依然是串行文件传输)</li><li>虽然复用了 TCP 连接, 但浏览器对请求的并发数有 6 ~ 8 条的限制</li></ol><p>为了解决串行文件传输的问题, 于是又有了<code>管线化(pipeline)</code>.<br>管线化是基于 <code>keep-alive</code> 通过一个连接把所有请求打包一次性发给服务端, 但响应时还是需要按请求顺序返回. 也就是说如果客户端发送了请求 123, 服务端处理时请求 23 先处理完了, 也必须等到请求 1 处理完才能按顺序应答响应 123, 所以其实也没完全解决问题. </p><blockquote><p>管线化使用队列的方式实现的对性能消耗很大, 因此也是管线化没有被广泛使用的原因</p></blockquote><p>小结: HTTP1.x 搞了这么多还是没解决的<code>队头阻塞</code>的问题, 除了队头阻塞之外, 其实还有<code>明文传输</code>带来的安全问题/ 建立 TCP 带来的<code>连接延时</code> / 标识链接的五元组在网络切换时带来的<code>链接迁移</code>问题</p><h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><p>HTTP2.0 在 1.x 的基础上又做了诸多优化, 特别在针对 <code>队头阻塞</code> 的问题上. 下面就分别说说 HTTP2.0 做了些什么</p><p><strong>多路复用</strong><br>主要就是解决 <code>队头阻塞</code> 的问题, 在 2.0 中引进了<code>帧(frame)</code> 和 <code>流(stream)</code> 两个重要的概念.</p><ul><li>帧(frame): 代表了最小数据的单位, 大体分为: header frame(头部帧) 和 data frame(数据帧)</li><li>流(stream): 是连接中的虚拟通道, 可以承载双向数据流, 也就是说同一个流中可以同时接收和发送数据, 每个流会有一个唯一的 ID. 同时流中的二进制帧都是并行传输, 无需按顺序等待</li></ul><p>多路复用让所有请求都在一个 TCP 中并发完成, TCP 中可以承载不限数量的流, 请求又是基于流的, 流中的消息又由二进制帧组成, 帧会标识属于哪个流, 因此可以做到乱序传输</p><p><strong>头部压缩</strong><br>之前提到 1.x 在传输过程中是通过文本传输的, 在每次传输过程中的很多头部信息都是一样的, 如果再加上一些 cookie 等保存状态的信息, 就会导致头部信息的体积较大, 带来性能上的浪费.</p><p>在 2.x 中会用两种方案来解决:</p><ol><li>用一个叫 <code>HPACK</code> 的算法来压缩头部字段的体积</li><li>发送方和接收方会共同维护一个<code>头部表</code>, 来防止每次传输相同头部字段. 对重复的头部字段不再每次发送, 当修改或者新增字段再更新这个头部表</li></ol><p><strong>服务端推送</strong><br>1.x 中一个请求只能对应一个响应, 在 2.x 中可以对一个请求响应多个结果. 比如: 请求 HTML 文件时, 服务端可以将 HTML 中用到的资源一并发送回来</p><p>当然 HTTP2.x 也不是没有<strong>缺点</strong>:</p><ul><li>基于 TCP 的 HTTP 在<strong>建立连接依然耗时</strong>, 至少都要经历三次握手, 如果有 TLS 时间更长</li><li>多路复用只解决了 HTTP 层面上的队头阻塞, 而在 <strong>TCP 层面上的队头阻塞依然没有解决</strong>. 是因为 TCP 为了保证数据的有序性, 要等待所有数据到达后排序整合, 所以一旦发生丢包就必须等待重传, 从而阻塞 TCP 上的所有请求</li><li>由于多路复用不限制流数量, 导致<strong>服务器压力可能会突然暴增</strong>, 同时<strong>超时</strong>的几率也更大</li><li>网络切换时也<strong>无法保持连接</strong></li></ul><h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><p>基于 HTTP2.x 缺点大多都是 TCP 层面上的特性, 但是如果要改造 TCP 成本和难度都会非常高, 目前已经有非常多的应用是基于 TCP 的, 兼容也是一个比较大的问题. 所以在 HTTP3.0 中就干脆抛弃了 TCP 改用 UDP.</p><p>那我们复习一下 UDP 的特性:</p><ul><li>面向无连接, 没有建立连接的过程</li><li>面向报文</li><li>不会保证包顺序或包是否丢失</li><li>可一对多/多对多等交互通信</li></ul><p>可以看到对 TCP 耗时的建连和队头阻塞 UDP 天然就能解决, 改造的负担相对也较小, 那么谷歌就在 UDP 的基础上改造出了一个具备 TCP 有点的 <code>QUIC</code> 协议. <code>QUIC</code> 协议是怎么做到让 UDP “可靠”的呢</p><p><strong>低延迟等待</strong><br>是为了解决 TCP 建立连接至少要 1RTT (三次握手: 一来一回, 再一应答), 如果是 HTTPS 的话那就是 3RTT, 如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/28c3bd933e574b649bad46d6c26a0b4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NDIzMTU0,size_16,color_FFFFFF,t_70" alt="HTTPS 建连过程"></p><blockquote><p>RTT 是 Round Trip Time 的缩写，通俗地说，就是通信一来一回的时间</p></blockquote><p>而 <code>QUIC</code> 可以达成0RTT建立连接，第一个数据包就可以传输数据. 但是 QUIC 的 0RTT 不是没有条件的, 对于首次连接还是需要 1RTT 来进行密钥协商. 因此建连主要分为两个部分 <code>首次连接</code> 和 <code>非首次连接</code></p><p>首次连接使用 <code>DH</code> 算法交换密钥, 过程如下:</p><ol><li>客户端对于首次连接的服务端先发送client hello请求</li><li>服务端生成一个素数p和一个整数g，同时生成一个随机数为私钥，然后计算出公钥。服务端将公钥，p，g三个元素打包成为 <code>config</code> ，后续发送给客户端</li><li>客户端随机生成一个自己的私钥，再<strong>根据 config 计算出自己的公钥</strong></li><li>客户端使用自己的<code>私钥</code>和 config 中读取的<code>服务端公钥</code>，生成后续数据加密用的 <code>密钥K</code></li><li>客户端使用 <code>密钥K</code> 加密业务数据，并追加自己的 <code>公钥</code>，都传递给服务端</li><li>服务端根据自己的 <code>私钥</code> 和 <code>客户端公钥</code> 计算出客户端加密用的<code>密钥K</code>, 解密数据</li><li>为了保证数据安全，上述生成的 <strong>密钥K 只会生成使用1次</strong>，后续服务端会按照相同的规则生成一套全新的公钥和私钥，并使用这组公私钥生成新的密钥M</li><li>服务端将新公钥和新密钥M加密的数据发给客户端，客户端根据新的服务端公钥和自己原来的私钥计算出本次的密钥M，进行解密</li><li>之后的客户端和服务端数据交互都使用密钥M来完成，密钥K只使用1次</li></ol><p>非首次连接<br>因为首次连接时, 客户端储存了服务端的 config(服务器公钥/p/g), 因此后续的连接可以直接用 config 计算通信的秘钥. 从而跳过秘钥协商实现 0RTT. <em>注: config 有时间限制, 如果过期仍然需要首次连接的密钥交换</em></p><p><strong>多路复用</strong><br>3.0 的多路复用完美解决了队头阻塞的问题, 它跟 2.0 的多路复用一样在同一个连接上可以创建多个流. 不同的是 <code>QUIC</code> 协议是基于 UDP 的, 所以 <code>每个流之间没有依赖</code>.</p><blockquote><p>也就是说就算一个 stream1 中发生了丢包,  虽然 stream1 丢失的包依然需要等待重传, 但是不影响其他 stream 的数据发送</p></blockquote><p><strong>前向安全</strong><br>是指密钥泄露也不会让之前的数据被泄露, 只影响当前. 所以每次通讯的 <code>密钥只会使用一次</code>, 交互完之后将其销毁, 再重新生成. 这样即使密钥泄露, 对方也只能获取对应那条密钥的消息</p><p><strong>前向纠错</strong><br>TCP 是每次丢包重传, QUIC 是将每组数据包进行运算, 将结果作为一个 <code>校验</code> 和<code>数据包</code>发送. 如果这组数据丢包, 就可以通过校验与其他包来还原丢包数据</p><p><strong>连接迁移</strong><br>TCP 五元组（源IP，源端口，目的IP，目的端口，传输层协议）来唯一表示一条连接. QUIC 则是生成一个 <code>64 位随机数作为连接唯一标识</code> , 这样就算切换网络五元组变化这个标识也不会变, 就可以快速重连</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>HTTP 是一种超文本协议, 用于在网络中将发送方的超文本信息传输给接收端<br>HTTP1.0:</p><ul><li>每次请求都需要重新建立 TCP 连接, 带来 <code>重复建立 TCP 连接</code> 的性能消耗和 <code>队头阻塞</code> 的问题</li></ul><p>HTTP1.1: </p><ul><li>使用 <code>Keep-Alive</code> 来复用 TCP 连接发送多次请求. 应用中可以通过不同域名来提高并发量, 但浏览器有限制 6 ~ 8 个并发请求数量的条件. 而同一条 TCP 中的请求-响应依然是阻塞的</li><li><code>管线化</code> 基于 Keep-Alive 将所有请求打包一次性发送到服务端, 解决请求阻塞的问题. 但服务端响应时还是必须按请求顺序依次返回, 由于性能问题管线化也没有被广泛使用</li></ul><p>HTTP2.0: </p><ul><li><code>多路复用</code>引入 <code>帧</code> 和 <code>流</code> 的概念. 在同一个 TCP 连接中, 所有请求都基于流并可以承载不限数量的流, 流中的信息由二进制帧组成, 帧中会标识所属流, 从而实现乱序发送. 但 TCP 层面的队头阻塞仍然存在, 一个流中发生丢包, 可能阻塞整条 TCP 中的流</li><li>通过 HPACK 算法进行 <code>头部压缩</code>, 同时发送和接收端共同维护头部表, 避免每次传递相同头部字段</li><li>利用 <code>服务端推送</code> 实现一个请求服务端能够应答多个响应</li></ul><p>HTTP3.0: 基于 UDP 实现拥有 TCP 优点的 <code>QUIC</code> 协议.</p><ul><li>利用 UDP 面向无连接的特性, 配合首次连接 1RTT 实现 <code>低延迟等待</code></li><li>跟 HTTP2.0 一样使用 <code>多路复用</code> 完美解决队头阻塞. 因为 UDP 中流之间不会相互依赖, 一个流中丢包完全不影响其他流发送数据</li><li>通信过程中使用一次性秘钥来保证 <code>向前安全</code>, 就算当前通讯中密钥被劫持, 也不用担心之前的数据也会被窃取了</li><li>通过 <code>向前纠错</code> 将数据包分为校验包和数据两部分, 数据丢包时可以通过其他数据包来还原(丢太多还是要重传).</li><li>算法生成一个 64 为随机数作为连接标识符, 替代 TCP 中五元组作为标识符, 保证 <code>连接迁移</code> 时能快速重连</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP 发展至今已经发生了太多的变化, 平常工作中其实并不会注意这些变化, 甚至说根本不关心… 但在前端的工作中却与它密切相关,从通信到性能优化等等. 下面就来聊聊 HTTP&lt;/p&gt;
&lt;h4 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="网络" scheme="https://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>可靠的TCP传输协议</title>
    <link href="https://yoursite.com/2022/03/24/%E5%8F%AF%E9%9D%A0%E7%9A%84TCP%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    <id>https://yoursite.com/2022/03/24/可靠的TCP传输协议/</id>
    <published>2022-03-24T12:00:53.000Z</published>
    <updated>2022-08-23T09:37:40.692Z</updated>
    
    <content type="html"><![CDATA[<p>提到 <code>TCP</code> 协议大家印象最深刻的应该就是”可靠性”这三个字了, 因此为了保证”可靠性”真的是用了好多机制来保证😂 . <em>不知道当初设计 TCP 的大佬们看到现在的 <code>QUIC</code> 协议会不会觉得好气</em></p><p>那么为了实现可靠性, TCP 到底做了哪些事呢? 主要要是通过 <code>数据序列号</code> / <code>确认应答</code> / <code>流量控制</code> / <code>拥塞控制</code> / <code>重发机制</code> 这几个机制来实现的, 下面就一次聊聊这些机制到底在做些什么.</p><h4 id="数据序列号和确认应答"><a href="#数据序列号和确认应答" class="headerlink" title="数据序列号和确认应答"></a>数据序列号和确认应答</h4><p>首先 TCP 协议是面向字节流的, 而经过 TCP 协议的数据会被拆分到多个数据段中, 每个数据段中都会包含一个序列号的协议头, 这个序列号就是我们所说的数据序列号了.</p><p>那确认应答是啥呢? 在 TCP 中, 当发送端发送的数据到达接收端时, 接收端会回复一个确认应答的消息, 表示已收到消息. 而这个应答消息也就是我们常说的 ACK(Acknowledge character）报文段</p><blockquote><p>ACK 是指 TCP 的报文到达确认, 确认接收到的数据的最高序列号，同时向发送端返回一个下次接收时期望的 TCP 数据包的序列号(也就是 ACK 的值)</p></blockquote><p>那么在网络过程中, 数据的传输过程中大概会是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主机 A                                      主机 B</span><br><span class="line">      ----    数据 1 ~ 100   ------&gt;</span><br><span class="line">      &lt;--- 确认应答(下一个101) ------</span><br><span class="line">      ---- 数据 101 ~ 200    ------&gt;</span><br><span class="line">      &lt;--- 确认应答(下一个201) ------</span><br></pre></td></tr></table></figure></p><p>但其实在网络, 并不会上述的过程中那么顺利, 那么当数据在传输过程中丢失了怎么办? 所以有了<code>重传机制</code></p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>重传机制主要有四种方式: <code>计时重传</code> / <code>快速重传</code> / <code>带确认重传(SACK)</code> / <code>D-SACK</code></p><p><strong>计时重传</strong><br>计时重传是指在发送数据时, 启动一个计时器, 当超过指定时间后没有收到对方的 <code>ACK</code> 确认应答报文, 那么就会重新发送数据同时降低发送速率. </p><blockquote><p>举例来说:<br>假如传输的数据 12345, 1 丢掉了, 2345 被接收到了, 因为丢掉了数据包 1 所以接收方没法发送 ACK 报文. 那么发送方也就只能等着接收方发 ACK, 双方就只能死等数据段 1, 从而造成超时. 而超时之后发送方并不知道丢了那些数据段, 就只能悲观的认为数据 1 之后的数据也都丢了, 那么就要重传所有数据段.</p></blockquote><p>从上面的过程中, 我们可以发现计时重传会有两个问题:</p><ol><li>只有等超时后才能重传</li><li>不知道重传数据范围</li></ol><p><strong>快速重传</strong><br>快速重传是基于计时重传, 主要解决了要等待超时才能重传的问题. 所以快速重传的做法是: 当接收方收到乱序包时, 立即发送 ACK 表明下个期望接收的数据(其实就是丢失的那个数据). 而发送方连续收到三次相同的 ACK 就会重传, 不需要等到是计时器超时.</p><p><strong>带确认重传(SACK)</strong><br>上面的快速重传解决了超时的问题, 那么剩应该重传数据范围的问题. 那么 SACK 就是在快速重传的基础上, 增加一个 <code>SACK</code> 的头, 将已收到的数据报文段的序列号范围告诉发送方, 这样发送方就可以只重传丢失的数据</p><p><img src="https://pic1.zhimg.com/80/v2-f65effd9010fbfe7f0ad0d3b256854e8_720w.jpg" alt="带确认重传过程"></p><p><strong>D-SACK</strong><br>D-SACK 主要是为了告诉发送方哪些数据重复接收了. 上面不是已经有 SACK 告诉发送方哪些数据报文段是已接收了的吗, 为啥还需要 D-SACK? 因为在网络中我们的 ACK 报文和数据段报文都可能会丢失呀! 比如以下两种情况:</p><ol><li><p>ACK 应答报文丢失: </p><ul><li>当接收方分别收到数据 1 和 2, 并回复 ACK = 2 和 ACK = 3</li><li>ACK 丢失了发送方一直收不到 ACK 自然无法触发快速重传</li><li>于是触发超时重传, 超时重传只好再重发一次数据 1. (造成重复数据)</li><li>接收方再次收到重发的数据, 响应 ACK = 3 和 SACK = 1 ~ 2</li></ul><p>此时的 SACK 就会变成表示重复收到的数据包范围, 这样发送方就知道了原来是接收方的 ACK 报文丢失了</p></li><li><p>网络延迟: </p><ul><li>发送方法送了数据 1234, </li><li>数据 2 延迟了一直没有到达接收方</li><li>数据 134 顺利达到于是接收方会分别回复三次 ACK = 2, SACK = 3 和 SACK = 3 ~ 4 触发到了快速重传</li><li>在快速重传的数据 2 达到之前, 先收到了之前延迟的数据 2, 在收到重发的数据 2 (造成重复数据)</li><li>接收方回复 ACK = 5 和 SACK = 2</li></ul><p>此时 ACK已经到了 5, SACK 还是 2 说明这个是重复数据. 同时发送方也知道了不是发出去的包丢失了, 也不是 ACK 报文丢了, 而是网络延迟了</p></li></ol><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制是为了防止发送方发送的速率太快, 导致接收方的缓存区溢出. 基本原理就是让发送方知道接收方的缓存区大小, 以调整发送速率.</p><p>这一原理通过滑动窗口来实现的, 其中接收方的缓存区大小叫做<code>接收窗口(rwnd)</code>大小, 发送方的发送速率由<code>发送窗口(swnd)</code>大小决定. 发送窗口的大小不能大于接收窗口的大小, 否则接收方就处理不过来了</p><blockquote><p>引入窗口的原因: 从上面传输数据的过程, 我们知道传输过程都是一来一回的, 所以数据的往返时间越长, 通讯效率就越差. 而窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值. </p></blockquote><p>以发送方的窗口为例: 窗口相当于开辟一个缓存区域, 将以发送的数据保存在缓存区中, 在收到 ACK 应答之前必须一直保存, 直到收到应答才清除缓存, 然后按收到应答的数据字节向右滑动. <em>注: 两个窗口的大小都是放在操作系统内存缓冲区中的，而操作系统的缓冲区会被操作系统调整</em></p><p><code>窗口关闭(死锁)</code><br>  当窗口不为 0 的应答丢失时，发送方会一直等待，而接收方以为发送方收到了则一直等待新数据，这样相互等待的过程就造成了死锁</p><p>解决方案:<br>  用持续计时器来解决，每当收到接收方窗口为 0 时，都启动一个计时器时间一到发送方就主动询问接收方窗口大小。如果还是 0 就重置计时器；不为 0 则表示之前的报文丢失了，重置窗口，再重新开始发送</p><p><code>糊涂窗口</code><br>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小. 到最后接收方窗口大小只有几个字节了, 发送方还是义无反顾的发送几个字节的数据. 这就是糊涂窗口</p><p>于是，要解决糊涂窗口综合症，有下面两个办法:</p><ul><li>让接收方不通告小窗口给发送方<ul><li>当窗口大小 &lt; Math.min(最大数据段数量MSS，缓存空间/2 ), 直接告诉发送方窗口为 0</li></ul></li><li>让发送方避免发送小数据<ul><li>要等到接收窗口大小 &gt;= MSS</li><li>收到之前发送数据的 ACK 回包</li></ul></li></ul><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>跟流量控制的区别在于, 拥塞控制作用于网络. 根据丢包情况和网络带宽防止过多数据注入网络，造成网络负载过大.</p><p>试想在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，然后进入恶性循环, 于是有了拥塞控制.</p><p>拥塞控制中, 会在发送方新增一个<code>拥塞窗口(cwnd)</code>的变量, 它随着网络拥塞程度动态变化. <em>注: 加入了拥塞窗口后, 发送窗口的值swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值</em></p><p>拥塞窗口 cwnd 变化的规则：</p><ul><li>只要网络中没有出现拥塞，cwnd 就会增大</li><li>但网络中出现了拥塞，cwnd 就减少</li></ul><p>那怎么判断网络出现拥塞了呢?<br>结合之前聊到的数据传递过程, 可以推断出当发送方没有及时收到 ACK 响应, 就可以认为是网络拥塞了</p><p>拥塞控制又控制些啥, 主要控制了四个算法: <code>慢启动</code> / <code>拥塞避免</code> / <code>快速重传</code> / <code>快速恢复</code>, </p><ul><li><p>慢启动<br>是指一点一点提高发送数据包的数量，发送方每收到一个接收方的 ACK 响应,  拥塞窗口大小就加倍，呈指数级增长.同时还会维护一个慢启动阈值(ssthresh)</p></li><li><p>拥塞避免<br>发送方每收到一个接收方的 ACK 响应,  拥塞窗口大小就 + 1，趁线性增长，减缓拥塞窗口增长速度</p><p>慢启动阈值会决定使用慢启动还是拥塞避免:</p><ul><li>当拥塞窗口大小 &lt; 慢启动阈值, 使用慢启动</li><li>拥塞窗口大小 &gt;= 慢启动阈值, 使用拥塞避免</li></ul></li><li><p>快速重传<br>当网络发生拥塞，接收方收到了三次重复 ACK，触发快速重传机制.<br>TCP 会认为这种情况没有很严重, 则调整拥塞窗口和慢启动阈值:</p><ul><li>拥塞窗口大小 = 拥塞窗口大小 / 2</li><li>慢启动阈值 = 拥塞窗口大小</li></ul><p>接着进入快速恢复</p></li><li><p>快速恢复<br>在基于快速重传将拥塞窗口大小 + 3（因为收到了三个数据包），重传丢失的数据包，收到 ACK 恢复了就进入拥塞避免算法，再次尝试让拥塞窗口增大</p></li></ul><p>如果网络拥塞到触发了计时重传, 那就一棒回到解放前, 重新开始慢启动来大幅减少数据流.同时慢启动阈值和拥塞窗口大小也会发生变化：</p><ul><li>慢启动阈值 设为 拥塞窗口大小/2</li><li>拥塞窗口大小 重置为 1</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TCP 的可靠性是由:</p><ul><li><code>序列号</code>和<code>确认应答</code>来保证数据到达接收方</li><li><code>流量控制</code>用滑动窗口来防止发送方发送速率过快导致接收方处理不过来</li><li><code>拥塞控制</code>用慢启动 / 拥塞避免 / 快速重传 / 快速恢复来防止大量数据在网络中造成拥堵, 从而造成更多数据延迟/丢包带来恶性循环</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提到 &lt;code&gt;TCP&lt;/code&gt; 协议大家印象最深刻的应该就是”可靠性”这三个字了, 因此为了保证”可靠性”真的是用了好多机制来保证😂 . &lt;em&gt;不知道当初设计 TCP 的大佬们看到现在的 &lt;code&gt;QUIC&lt;/code&gt; 协议会不会觉得好气&lt;/em&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="网络" scheme="https://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>傻傻分不清之作用域/执行上下文</title>
    <link href="https://yoursite.com/2022/03/21/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://yoursite.com/2022/03/21/傻傻分不清之作用域-执行上下文/</id>
    <published>2022-03-21T03:43:02.000Z</published>
    <updated>2022-08-23T09:37:40.692Z</updated>
    
    <content type="html"><![CDATA[<p>工作两三年中, 偶然听同事们在讨论作用域 balabala.. 仔细回想一下好像自己也不太能说清他俩的区别到底是啥, 于是进行了一波回炉重造</p><h3 id="从万物之源编译-JS开始"><a href="#从万物之源编译-JS开始" class="headerlink" title="从万物之源编译 JS开始"></a>从万物之源编译 JS开始</h3><p>JS 编译一共会经历四个阶段: 词法分析/语法分析/预编译/代码执行, 大致描述一下这四个阶段在做什么:</p><ul><li><p>词法分析: 将符号流转为记号流, 将代码分解成最小词法单元</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS 源代码</span></span><br><span class="line"><span class="keyword">var</span> AST = <span class="string">'tree'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解为词法单元，转化为这样👇🏻</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Keyword"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"var"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"AST"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Punctuator"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"="</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"String"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"'tree'"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Punctuator"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">";"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>语法分析: 再将记号流生成为抽象语法树(AST)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="string">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">      <span class="string">"declarations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">          <span class="string">"id"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"AST"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">"init"</span>: &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">            <span class="string">"value"</span>: <span class="string">"tree"</span>,</span><br><span class="line">            <span class="string">"raw"</span>: <span class="string">"'tree'"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"kind"</span>: <span class="string">"var"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"sourceType"</span>: <span class="string">"script"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>预编译</p><ul><li>创建执行上下文</li><li>确定变量对象、作用域链、this指向</li><li>变量对象填充顺序：函数形参、函数声明、变量声明</li></ul></li><li><p>代码执行</p></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>众所周知 JS 是词法作用域, 而词法作用域则决定了代码<strong>在书写的时候就会确定如何查找变量</strong>. 那么再回到 JS 的编译过程中, <strong>作用域是在词法分析阶段确定</strong>, 换而言之: 你如何书写代码就决定了当前代码块对变量或其他资源的访问权限, 而查找变量也是根据定义的位置向上查找.</p><p>举个🌰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是父级 window</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里是子级 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里是子级 2</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></p><p>从输出结果来看打印的是 2 而不是 3. 我们结合词法作用域来分析, <code>foo</code> 方法的父级是 <code>window</code> 而不是 <code>bar</code>. 所以当我们在 <code>foo</code> 方法中查找 a 变量时, 在当前作用域中没找到, 就会继续向上查找从而在父级 <code>window</code> 中找到了 <code>var a = 2</code>. 由此可以看出我们查找变量时, 与函数在何处调用的无关, 而是跟定义位置有关</p><p>同时作用域也是一个分层和独立的区域, 分层表示: 内部作用域可以访问外部作用域的变量; 独立表示: 可以保证变量不对外暴露. 同样也举个🌰来说:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">  <span class="keyword">const</span> inner = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 内部作用域 inner 可以访问到父级 wrapper 的变量 a</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner() <span class="comment">// 输出: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局作用域则访问不到内部作用域 wrapper 中的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Error: a is not defined</span></span><br></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>刚刚提到了当我们在查找变量时, 如果在当前作用域中没有找到, 会继续向上在父级作用域中去找. 那么当前作用域怎么知道我有哪些父级作用域呢?</p><p>这是因为函数中有一个私有属性<code>[[scope]]</code>, 当函数在创建的时候(预解析阶段), 会保存父级的所有变量对象指针到<code>[[scope]]</code> 属性中<em>注: 函数的 <code>[[scope]]</code> 属性并不是作用域链</em>, be like:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inner = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当函数创建时:</span></span><br><span class="line">wrapper.[[scope]] = [</span><br><span class="line">  gobalContext.VO</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">inner.[[scope]] = [</span><br><span class="line">  wrapperContext.AO</span><br><span class="line">  gobalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>后续执行 wrapper 函数创建执行上下文时(预编译阶段), 进入函数上下文并创建 VO/AO, 就会将活动对象添加到作用域顶端<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrapperContext = &#123;</span><br><span class="line">  AO: &#123;&#125;, <span class="comment">// 活动对象: wrapper 函数的参数以及变量</span></span><br><span class="line">  Scope: [AO, wrapper.[[scope]]] <span class="comment">// !!! 这才是作用域链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>关于 <code>[[scope]]</code> 和执行上下文中 <code>Scope</code> 的理解:<br>当你定义(书写)一个函数时, JS 引擎可以根据你书写的位置: 函数嵌套的位置, 生成一个[[scope]] 属性, 这个属性是属于函数的(即使函数不调用), 所以说基于词法作用域(静态的)<br>而 Scope 属性是在函数执行时, 生成执行上下文(VO/Scope/this), 这个是时候的 Scope 和 [[scope]] 不是同一个东西. Scope 是在 [[scope]] 的基础上新增了当前的 AO 对象来构成<br>所以函数定义时的[[scope]]是函数的属性, 函数执行时的 Scope 是执行上下文的属性</p></blockquote><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>前面我们提到 VO/AO 这两个东西, 之前我们一直在说作用域和作用域链是怎么来的, 但还没提到里面的变量是如何填充进去供访问时使用的. 下面我们就来聊聊变量是如何保存和填充的</p><p>在 JS 编译过程中有提到一个叫预编译的阶段, 在这个阶段中 JS 会对可执行代码进行一个 “准备工作” 也就是<code>执行上下文</code>, 之后运行的代码都是在执行上下文中运行. 它一共有三种类型: 全局上下文/函数上下文/eval 上下文</p><p>对于每个执行上下文, 都有三个重要的属性:</p><ul><li>变量对象(VO): 储存上下文中定义的变量和函数声明</li><li>作用域链</li><li>this</li></ul><p><strong>变量对象/活动对象</strong></p><ul><li><p>全局上下文中的变量对象(VO)其实就是全局对象</p></li><li><p>对于函数上下文来说, 我们用活动对象(AO: activation object)来表示变量对象</p></li></ul><p>小总结一下: 活动对象和变量对象其实是一个东西, 只是变量对象是在引擎上实现的不可以在 JS 环境中被访问. 只有当进入一个执行上下文时, 这个执行上下文的变量对象才会被激活, 而只有被激活的变量对象时, 也就是活动对象上的属性才能被我们访问</p><p><strong>填充过程</strong><br>执行上下文会被分为两个阶段处理:</p><ol><li>创建执行上下文:<br>此时变量对象会包括<ol><li>函数形参(如果是函数上下文的话)<ul><li>key: 形参名称</li><li>value: 实参的值(没有就是 undefined)</li></ul></li><li>函数声明<ul><li>key: 函数名称 (会覆盖同名的函数声明)</li><li>value: 函数对象</li></ul></li><li>变量声明 (会覆盖同名的函数声明或参数会忽略)<ul><li>key: 变量名称</li><li>value: undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 AO 为</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">undefined</span>,</span><br><span class="line">  c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  d: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><blockquote><p>创建完变量对象后, 就会创建作用域链把 AO 添加到作用域链前端. 同时 This 的执行也会在创建阶段确定</p></blockquote><ol start="2"><li>执行阶段: 根据代码修改变量对象中的值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 AO 更新为</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  <span class="built_in">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    length: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">3</span>,</span><br><span class="line">  c: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  d: reference to FunctionExpression <span class="string">"d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>而我们熟知的执行上下文栈就是用来管理多个执行上下文的, 当 JS 开始要执行代码时, 首先遇到的就是全局代码, 所以初始化的时候会先向执行上下文栈中压入一个全局执行上下文, 直到所有代码执行完之前栈底始终都会有一个<code>globalContext</code>. 我们来模拟一个执行上下文栈的行为增强理解:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始执行</span></span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到这段代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fun3'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun2();</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先执行 fun1</span></span><br><span class="line">ECStack.push(fun1) <span class="comment">// fucntionContext</span></span><br><span class="line"><span class="comment">// fun1 中调用了 fun2, 创建 func2 的执行上下文</span></span><br><span class="line">ECStack.push(fun2) <span class="comment">// fucntionContext</span></span><br><span class="line"><span class="comment">// fun2 中调用了 fun3, 创建 func3 的执行上下文</span></span><br><span class="line">ECStack.push(fun3) <span class="comment">// fucntionContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line">ECStack.pop()</span><br><span class="line"><span class="comment">// fun2执行完毕</span></span><br><span class="line">ECStack.pop()</span><br><span class="line"><span class="comment">// fun3执行完毕</span></span><br><span class="line">ECStack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有代码执行完毕</span></span><br><span class="line">ECStack.pop() <span class="comment">// 弹出 globalContext</span></span><br></pre></td></tr></table></figure><h3 id="有点懵逼-捋一捋-用-ES3"><a href="#有点懵逼-捋一捋-用-ES3" class="headerlink" title="有点懵逼, 捋一捋(用 ES3)"></a>有点懵逼, 捋一捋(用 ES3)</h3><p>以下面的例子为例, 从创建函数作用域到变量对象填充的全过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">'global scope'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">localfunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="string">'local scope'</span></span><br><span class="line">  <span class="keyword">return</span> local</span><br><span class="line">&#125;</span><br><span class="line">localfunction()</span><br></pre></td></tr></table></figure><ol><li><p>词法分析阶段: 创建函数作用域, 注意创建函数作用域时, 是词法作用域!!!</p></li><li><p>创建函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 globalContext 的时候就会创建函数</span></span><br><span class="line"><span class="comment">// 保存父级变量对象的引用到, 函数的 [[scope]] 属性</span></span><br><span class="line">localfunction.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>预编译阶段: 创建函数执行上下文并压入执行上下文栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建的 lcoalContext 压入 local 执行上下文</span></span><br><span class="line">ECStack = [</span><br><span class="line">  lcoalContext,</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制[[scope]] 初始化作用域链</span></span><br><span class="line">lcoalContext = &#123;</span><br><span class="line">  Scope: localfunction.[[scope]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建活动对象, 初始化 Arguments 对象</span></span><br><span class="line">lcoalContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    local: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: localfunction.[[scope]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将活动对象压入 lcoal 作用域链顶端</span></span><br><span class="line">lcoalContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    local: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, localfunction.[[scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>准备工作完成, 执行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始执行函数, 修改 AO 属性值</span></span><br><span class="line">lcoalContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    local: <span class="string">'local scope'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, localfunction.[[scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码执行完毕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 localContext</span></span><br><span class="line">ECStack.pop()</span><br><span class="line"></span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h4 id="ES6-执行上下文-补充"><a href="#ES6-执行上下文-补充" class="headerlink" title="ES6 执行上下文(补充)"></a>ES6 执行上下文(补充)</h4><p>在 ES6 规范中去除了, 上面 ES3 版本中的变量对象/活动对象, 换成了<code>词法环境组件</code>(LexicalEnvironment component)和<code>变量环境组件</code>(VariableEnvironment component)替代</p><p>同样分两个阶段:</p><ul><li><p>创建阶段</p><ol><li>确定 this 的值, 也就是 This Binding(全局执行上下文指向全局对象; 函数上下文取决于函数如何被调用)</li><li><p>创建<code>词法环境组件</code>, 有两种类型: <code>全局环境</code>/<code>函数环境</code>. 词法环境内部有两个组件: <code>环境记录器</code>和<code>外部环境的引用</code>. 其中环境记录器也有两种类型: <code>对象环境记录器</code>用来定义全局环境中的变量和函数; <code>声明式环境记录器</code>用来储存函数环境中的变量、函数和参数</p><ul><li>全局环境: 对象环境记录器中包含所有全局对象, 外部环境的引用为 null</li><li>函数环境: 声明式环境记录器储存本地变量、函数和参数, 外部环境的引用包含父级词法环境(类似 ES3 的作用域链)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局执行上下文</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  <span class="comment">// 词法环境</span></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    <span class="comment">//环境记录器</span></span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Object'</span>, <span class="comment">// 对象环境记录器</span></span><br><span class="line">      <span class="comment">// 对外部环境的引用</span></span><br><span class="line">      outer: <span class="string">'&lt;null&gt;'</span> <span class="comment">// 这里并不是字符串, 只是为了让代码识别😂</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数执行上下文</span></span><br><span class="line">FunctionExectionContext  = &#123;</span><br><span class="line">  <span class="comment">// 词法环境</span></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    <span class="comment">//环境记录器</span></span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Declarative'</span>, <span class="comment">// 声明式环境记录器</span></span><br><span class="line">      <span class="comment">// 对外部环境的引用</span></span><br><span class="line">      outer: <span class="string">'&lt;Global or outer function environment reference&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建<code>变量环境组件</code>: 其实也是一种词法环境, 所以它也拥有词法环境的所有属性. 词法环境和变量环境的区别: </p><ul><li>词法环境: 储存函数声明和 <code>let</code>/<code>const</code> 关键字声明的变量, 在函数级作用域的基础上实现了块级作用域</li><li>变量环境: 储存 <code>var</code> 关键字声明的变量, 实现了函数级作用域<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过例子来看</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">e, f</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> g = <span class="number">3</span>;  </span><br><span class="line">  <span class="keyword">return</span> e + f + g;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = foo(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上下文的伪代码:</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  ThisBinding: <span class="string">'&lt;Global Object&gt;'</span>,</span><br><span class="line">  LexicalEnvironment: &#123; <span class="comment">// 储存函数声明和 let/const 的变量</span></span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Object'</span>, <span class="comment">// 对象环境记录器</span></span><br><span class="line">      a: <span class="string">'&lt; uninitialized &gt;'</span>, <span class="comment">// 注意⚠️: 这里并没有像 ES3 一样初始化成 undefined</span></span><br><span class="line">      b: <span class="string">'&lt; uninitialized &gt;'</span>,</span><br><span class="line">      foo: <span class="string">'&lt; func &gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="string">'&lt;null&gt;'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123; <span class="comment">// var 的变量</span></span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Object'</span>,</span><br><span class="line">      c: <span class="literal">undefined</span>, <span class="comment">// 初始化成了 undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    outer: <span class="string">'&lt;null&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: <span class="string">'&lt;Global Object&gt;'</span>,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Declarative'</span>, <span class="comment">// 声明式环境记录器</span></span><br><span class="line">      Arguments: &#123;<span class="number">0</span>: <span class="number">3</span>, <span class="number">1</span>: <span class="number">4</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="string">'&lt;GlobalLexicalEnvironment&gt;'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: <span class="string">'Declarative'</span>,</span><br><span class="line">      g: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    outer: <span class="string">'&lt;GlobalLexicalEnvironment&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><blockquote><p>可以看出 ES6 中, var 和 let/const 能够共存也是因为词法环境和变量环境的区分. 发生变量提升也是因为变量环境中初始化变量赋值成了 undefined, 而词法环境中的变量则保持了未初始化.</p></blockquote><ul><li>执行阶段: 代码执行, let/const 声明的变量没有找到值的话才会赋值为 undefined</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>作用域: 决定了代码块中如何访问变量或其他资源, 在在词法分析时就确定了</li><li>执行上下文: 用来评估代码环境, 包括三个重要属性: 变量对象/作用域链/this. 代码执行时才能确定具体值, 随时可能会改变</li><li>作用域链: 决定如何查找变量或其他资源, 会先从当前作用域下执行上下文中的变量对象中查找变量, 如果没有找到会沿着<strong>词法作用域的父级</strong>向上查找父级作用域下执行上下文的变量对象中查找, 直到全局作用域. 这样由多个执行上下文的变量对象构成</li><li>执行上下文栈: 用来管理多个执行上下文, 每当遇到一个函数调用都会为其创建一个新的执行上下文并压入栈中, 函数执行完毕后弹出</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作两三年中, 偶然听同事们在讨论作用域 balabala.. 仔细回想一下好像自己也不太能说清他俩的区别到底是啥, 于是进行了一波回炉重造&lt;/p&gt;
&lt;h3 id=&quot;从万物之源编译-JS开始&quot;&gt;&lt;a href=&quot;#从万物之源编译-JS开始&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网络摄像机直播</title>
    <link href="https://yoursite.com/2018/05/06/%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E6%9C%BA%E7%9B%B4%E6%92%AD/"/>
    <id>https://yoursite.com/2018/05/06/网络摄像机直播/</id>
    <published>2018-05-06T06:49:04.000Z</published>
    <updated>2022-08-23T09:37:40.693Z</updated>
    
    <content type="html"><![CDATA[<p>对于网络摄像机做视频预览这块, 本身其实是非常陌生的, 当时接到这个需求也是相当的头疼(对于当时一年经验不到的我来说).当时我们的应用场景是: 多路网络摄像机通过局域网连接, PC 端能够实时预览监控画面并且画质达到720p, 延迟不能超过10秒, 多个摄像机能够切换查看. 由于后端只提供一个 RTSP 的直播协议, 所以所有的方案都是围绕着 RTSP 这个关键词.</p><blockquote><p> 当时时间很赶所以要自己慢慢研究是不可能了, 只能去找现成的库. 现目前用过三种方案, 都不完美.</p></blockquote><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>经过一波调研(google)之后, 知道浏览器对 RTSP 协议并不友好, 也就是说我们必须要自己转码再提供给浏览器使用, 找到的解决思路大概是:</p><ol><li>转码: <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 是一个老牌的转码工具, 非常强大</li><li>Node.js 用作中转站接收客户端发来的摄像机信息及控制 FFmpeg 推流</li><li>最终客户端接收视频流</li></ol><p>下面我试过的三种方案, 基本结构都如此只是推流的方式和客户端的接收方式有所不同.</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>安装 FFmpeg 转码工具</strong></p><ul><li>window 平台</li></ul><ol><li><a href="http://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">下载 FFmpeg</a> 解压后应该是已经编译好的文件</li><li>将解压好的文件放入 C 盘根目录(也可以自行放入其他盘符)下重命名为 ffmpeg(方便以后找)</li><li>设置环境变量, 我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新增, 路径选择刚刚 C 盘下的 ffmpeg文件夹中的 bin 文件夹</li><li>注销或重启电脑让环境变量生效</li><li>测试, 在 cmd 中输入 <code>ffmpeg -version</code>,  如果出现版本号之类的东西则成功.</li></ol><ul><li>Mac 平台<br>Mac 下可以直接通过 <code>Homebrew</code> 安装最为简单.</li></ul><ol><li>安装 <code>Homebrew</code>, 在终端中输入 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li><li>安装 FFmpeg, 直接在终端中输入 <code>brew install ffmpeg</code> 即可</li><li>测试, 同样在终端中输入 <code>ffmpeg -version</code> 查看版本号</li></ol><p><strong>安装 Node.js</strong><br>这个就不展开详细说了, 每个前端都有吧…</p><h3 id="方案一-img-标签"><a href="#方案一-img-标签" class="headerlink" title="方案一: img 标签"></a>方案一: img 标签</h3><p>当时想到的第一种方案也是最简单的方案, 是将视频流的每一帧转化为 base64 再通过动态替换 <code>&lt;img&gt;</code> 的 src 属性来达到预览的效果.中间用到了<a href="https://github.com/agsh/rtsp-ffmpeg" target="_blank" rel="noopener">rtsp-ffmpeg</a>, 这个库的思路是通过 websocket 发送每一帧视频的 bytes 到客户端, 客户端可以通过 <code>&lt;img&gt;</code> 标签来展示.</p><p><strong>示例:</strong></p><p>node 端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br><span class="line"><span class="keyword">const</span> rtsp = <span class="built_in">require</span>(<span class="string">'rtsp-ffmpeg'</span>)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening on 8081'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri 以海康摄像机的 rtsp 协议为例</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> rtsp.FFMpeg(&#123;</span><br><span class="line">    input: uri,</span><br><span class="line">    resolution: <span class="string">'1080x720'</span>,</span><br><span class="line">    quality: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'stop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream stopped'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pipeStream = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">'data'</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, pipeStream)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换摄像机</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.port&#125;</span>/h264/ch1/sub/av_stream`</span></span><br><span class="line">        stream.input = uri</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重启</span></span><br><span class="line">        stream.restart()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span> () =&gt; &#123;</span><br><span class="line">        stream.removeListener(<span class="string">'data'</span>, pipeStream)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">'img'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'/socket.io/socket.io.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> io = io();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'#img'</span>)</span></span><br><span class="line"><span class="javascript">io.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> bytes = <span class="keyword">new</span> Unit8Array(data)</span></span><br><span class="line"><span class="javascript">        img.src = <span class="string">'data:image/jpeg;base64,'</span> + base64ArrayBuffer(bytes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// byte 数组转 base64 (这段是在其他地方抄的)</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">base64ArrayBuffer</span>(<span class="params">arrayBuffer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> base64    = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> encodings = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> bytes         = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arrayBuffer);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength    = bytes.byteLength;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteRemainder = byteLength % <span class="number">3</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mainLength    = byteLength - byteRemainder;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a, b, c, d;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> chunk;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Main loop deals with bytes in chunks of 3</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mainLength; i = i + <span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Combine the three bytes into a single integer</span></span></span><br><span class="line"><span class="undefined">chunk = (bytes[i] &lt;&lt; 16) | (bytes[i + 1] &lt;&lt; 8) | bytes[i + 2];</span></span><br><span class="line"><span class="javascript"><span class="comment">// Use bitmasks to extract 6-bit segments from the triplet</span></span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">16515072</span>) &gt;&gt; <span class="number">18</span>; <span class="comment">// 16515072 = (2^6 - 1) &lt;&lt; 18</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">258048</span>)   &gt;&gt; <span class="number">12</span>; <span class="comment">// 258048   = (2^6 - 1) &lt;&lt; 12</span></span></span><br><span class="line"><span class="javascript">c = (chunk &amp; <span class="number">4032</span>)     &gt;&gt;  <span class="number">6</span>; <span class="comment">// 4032     = (2^6 - 1) &lt;&lt; 6</span></span></span><br><span class="line"><span class="javascript">d = chunk &amp; <span class="number">63</span>;               <span class="comment">// 63       = 2^6 - 1</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Convert the raw binary segments to the appropriate ASCII encoding</span></span></span><br><span class="line"><span class="undefined">base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Deal with the remaining bytes and padding</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (byteRemainder == <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="undefined">chunk = bytes[mainLength];</span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">252</span>) &gt;&gt; <span class="number">2</span>; <span class="comment">// 252 = (2^6 - 1) &lt;&lt; 2</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Set the 4 least significant bits to zero</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">3</span>)   &lt;&lt; <span class="number">4</span>; <span class="comment">// 3   = 2^2 - 1</span></span></span><br><span class="line"><span class="javascript">base64 += encodings[a] + encodings[b] + <span class="string">'=='</span>;</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (byteRemainder == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="undefined">chunk = (bytes[mainLength] &lt;&lt; 8) | bytes[mainLength + 1];</span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">64512</span>) &gt;&gt; <span class="number">10</span>; <span class="comment">// 64512 = (2^6 - 1) &lt;&lt; 10</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">1008</span>)  &gt;&gt;  <span class="number">4</span>; <span class="comment">// 1008  = (2^6 - 1) &lt;&lt; 4</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Set the 2 least significant bits to zero</span></span></span><br><span class="line"><span class="javascript">c = (chunk &amp; <span class="number">15</span>)    &lt;&lt;  <span class="number">2</span>; <span class="comment">// 15    = 2^4 - 1</span></span></span><br><span class="line"><span class="javascript">base64 += encodings[a] + encodings[b] + encodings[c] + <span class="string">'='</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> base64;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这种通过 img 的方式暴露出的问题是需要在前端解码, 导致下一帧到来时上一帧的画面还没解码完成. 就会有花屏甚至画面只显示一半的问题和延迟较大且延迟会累积, 在控制台中你会看到疯狂刷从内存来的请求, 如果你想看看 http 请求可能会疯. 所以这种方式肯定不行</p><p>这个 <code>rtsp-ffmpeg</code> 还提供一种 canvas 的方式, 只是在客户端做一些修改:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = io();</span><br><span class="line"><span class="comment">// 把之前的 img 标签换成 canvas</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>)</span><br><span class="line">io.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([bytes], &#123;<span class="attr">type</span>: <span class="string">'application/octet-binary'</span>&#125;)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line">        img.width = img.width * <span class="number">0.5</span></span><br><span class="line">        img.height = img.height * <span class="number">0.5</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            URL.revokeObjectURL(url)</span><br><span class="line">            ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1080</span>, <span class="number">720</span>)</span><br><span class="line">        &#125;;    </span><br><span class="line">    img.src = url</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>用 canvas 的方法虽然比 img 的效果好一点, 但是最终效果仍然是不尽人意. 图像很不稳定, 表现为一半画面一半绿屏, 如果视频中图像变换剧烈的话表现会更差, 所以这种方法也不太行. 其实在这中间我并没有做什么操作只是将这个 demo 集成在了 vue 中, 再加上多摄像机的切换和主流摄像机厂商的支持(因为每个摄像机厂商的 rtsp 协议的结构不一样)而已, 所以第一想法是能不能在解码这块找到更好解决办法, 于是又找到了另一个库 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener">jsmpeg</a> 方案二就来了.</p><h3 id="方案二-jsmpeg"><a href="#方案二-jsmpeg" class="headerlink" title="方案二: jsmpeg"></a>方案二: jsmpeg</h3><p>这个库还算比较不错的了, 也是通过 websocket 来转发, 看官方的例子是在终端中启动 ffmpeg -&gt; websocket -&gt; 客户端通过 <code>jsmpeg.min.js</code> 解码在 canvas 中播放. 因为这里只是实现了播放, 在这个基础上我们还需要在脚本中自启 ffmpeg / 切换/ 重启, 然后又去找了一个基于 <code>jsmpeg</code> 的库 <a href="https://github.com/kyriesent/node-rtsp-stream" target="_blank" rel="noopener">node-rtsp-stream</a>. 这个库只是做了一些封装让我们不用自己在终端中手动启用 ffmpeg, 在此之上我再加上重启就能满足现在的需求.</p><p><strong>示例:</strong></p><ol><li>改造 <code>node-rtsp-stream</code></li></ol><p>node-rtsp-stream/videoStream.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;</span><br><span class="line"></span><br><span class="line">    ws = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">    events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line">    Mpeg1Muxer = <span class="built_in">require</span>(<span class="string">'./mpeg1muxer'</span>);</span><br><span class="line"></span><br><span class="line">    STREAM_MAGIC_BYTES = <span class="string">"jsmp"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">    VideoStream = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = options.name;</span><br><span class="line">        <span class="keyword">this</span>.streamUrl = options.streamUrl;</span><br><span class="line">        <span class="keyword">this</span>.width = options.width;</span><br><span class="line">        <span class="keyword">this</span>.height = options.height;</span><br><span class="line">        <span class="keyword">this</span>.wsPort = options.wsPort;</span><br><span class="line">        <span class="keyword">this</span>.inputStreamStarted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.stream = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.startMpeg1Stream();</span><br><span class="line">        <span class="keyword">this</span>.pipeStreamToSocketServer();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    util.inherits(VideoStream, events.EventEmitter);</span><br><span class="line">    <span class="comment">// 停止视频流</span></span><br><span class="line">    VideoStream.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mpeg1Muxer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.stream.stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重启视频流</span></span><br><span class="line">    VideoStream.prototype.restart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mpeg1Muxer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.stream.stop()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ffmpeg is restart'</span>)</span><br><span class="line">            <span class="keyword">this</span>.inputStreamStarted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.stream = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.startMpeg1Stream();</span><br><span class="line">            <span class="comment">// 监听 ffmpeg 进程是否关闭</span></span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.on(<span class="string">'ffmpegClose'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ffmpeg closed on '</span> + code)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.startMpeg1Stream = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 省略打开流的方法, 这部分没有做改动</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.pipeStreamToSocketServer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将流塞给 socket, 同样也没改</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.onSocketConnect = <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self, streamHeader;</span><br><span class="line">        self = <span class="keyword">this</span>;</span><br><span class="line">        streamHeader = <span class="keyword">new</span> Buffer(<span class="number">8</span>);</span><br><span class="line">        streamHeader.write(STREAM_MAGIC_BYTES);</span><br><span class="line">        streamHeader.writeUInt16BE(<span class="keyword">this</span>.width, <span class="number">4</span>);</span><br><span class="line">        streamHeader.writeUInt16BE(<span class="keyword">this</span>.height, <span class="number">6</span>);</span><br><span class="line">        socket.send(streamHeader, &#123;</span><br><span class="line">            binary: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log((<span class="string">""</span> + <span class="keyword">this</span>.name + <span class="string">": New WebSocket Connection ("</span>) + <span class="keyword">this</span>.wsServer.clients.length + <span class="string">" total)"</span>);</span><br><span class="line">        <span class="keyword">return</span> socket.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code, message</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log((<span class="string">""</span> + <span class="keyword">this</span>.name + <span class="string">": Disconnected WebSocket ("</span>) + self.wsServer.clients.length + <span class="string">" total)"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.exports = VideoStream;</span><br><span class="line"></span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>node-rtsp-stream/videoStream.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Mpeg1Muxer, child_process, events, util;</span><br><span class="line"></span><br><span class="line">    child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">    events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line">    Mpeg1Muxer = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self;</span><br><span class="line">        self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.url = options.url;</span><br><span class="line">        <span class="keyword">this</span>.stream = child_process.spawn(<span class="string">"ffmpeg"</span>, </span><br><span class="line">            [</span><br><span class="line">                <span class="string">"-rtsp_transport"</span>,</span><br><span class="line">                <span class="string">"tcp"</span>,</span><br><span class="line">                <span class="string">"-i"</span>,</span><br><span class="line">                <span class="keyword">this</span>.url,</span><br><span class="line">                <span class="string">'-s'</span>, </span><br><span class="line">                <span class="comment">// 图像宽高</span></span><br><span class="line">                <span class="string">`<span class="subst">$&#123;options.width&#125;</span>x<span class="subst">$&#123;options.height&#125;</span>`</span>, </span><br><span class="line">                <span class="string">'-f'</span>, </span><br><span class="line">                <span class="string">'mpeg1video'</span>, </span><br><span class="line">                <span class="string">'-b:v'</span>, </span><br><span class="line">                <span class="string">'800k'</span>, </span><br><span class="line">                <span class="string">'-r'</span>, </span><br><span class="line">                <span class="string">'30'</span>, </span><br><span class="line">                <span class="string">'-'</span></span><br><span class="line">            ], </span><br><span class="line">            &#123;</span><br><span class="line">                detached: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">this</span>.inputStreamStarted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.stream.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'mpeg1data'</span>, data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.stream.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'ffmpegError'</span>, data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// kill ffmpeg</span></span><br><span class="line">        <span class="keyword">this</span>.stream.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(self.stream.pid)</span></span><br><span class="line">            self.stream.stdin.pause();</span><br><span class="line">            self.stream.kill()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ffmpeg is be kill'</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听 ffmpeg 退出</span></span><br><span class="line">        <span class="keyword">this</span>.stream.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'ffmpegClose'</span>, code)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    util.inherits(Mpeg1Muxer, events.EventEmitter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.exports = Mpeg1Muxer;</span><br><span class="line"></span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>node 端使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br><span class="line"><span class="comment">// 引入改造后的 node-rtsp-stream</span></span><br><span class="line"><span class="keyword">const</span> Rtsp = <span class="built_in">require</span>(<span class="string">'./node-rtsp-stream'</span>)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening on 8081'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri 以海康摄像机的 rtsp 协议为例</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> Rtsp(&#123;</span><br><span class="line">    name: <span class="string">'rtsp_stream'</span>,</span><br><span class="line">    streamUrl: uri,</span><br><span class="line">    wsPort: <span class="number">11111</span>,</span><br><span class="line">    width: <span class="number">720</span>,</span><br><span class="line">    height: <span class="number">405</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'stop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream stopped'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pipeStream = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">'data'</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, pipeStream)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换摄像机</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.port&#125;</span>/h264/ch1/sub/av_stream`</span></span><br><span class="line">        stream.streamUrl = uri;</span><br><span class="line">        <span class="comment">// 重启</span></span><br><span class="line">        stream.restart()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span> () =&gt; &#123;</span><br><span class="line">        stream.removeListener(<span class="string">'data'</span>, pipeStream)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>客户端</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">'can'</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'jsmpeg.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#can'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:11111'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> player = <span class="keyword">new</span> jsmpeg(ws, &#123;</span></span><br><span class="line"><span class="undefined">        canvas: canvas,</span></span><br><span class="line"><span class="javascript">        autoplay: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个方案其实使用了很久一直都没发现问题, 也没有出现过花屏延迟累计的情况. 但是在一路摄像机安置在天桥附近人流量剧增, 与这个视频预览同一页面还有一个人脸实时抓拍的即时消息推送的功能, 导致在20 - 30分钟浏览器直接假死或者崩溃.(然后这个方案又凉了😂)</p><h3 id="方案三-FFmpeg-Nginx-video-js"><a href="#方案三-FFmpeg-Nginx-video-js" class="headerlink" title="方案三: FFmpeg + Nginx + video.js"></a>方案三: FFmpeg + Nginx + video.js</h3><p>在经过两次实验 + 失败之后找到一个较为大众的解决方式, 前两种方案都是通过库直接使用 rtsp 转成 bytes 提供给外部使用, 而方案三的流程如下:</p><ul><li>Node 使用 <a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" target="_blank" rel="noopener">fluent-ffmpeg</a> 调整参数启动 FFmpeg</li><li>FFmpeg 负责编码再解码后转为 RTMP 协议</li><li>Node 将流推到 Nginx (nginx 需要安装 <a href="https://github.com/arut/nginx-rtmp-module#example-nginxconf" target="_blank" rel="noopener">nginx-rtmp-modules</a> 插件)</li><li>客户端使用 Video.js 访问 Nginx 配置的连接并播放视频</li></ul><p>在这个阶段又遇到了不同厂商的摄像机, 在同一协议下不能正常运作, 在此也记录一下各厂商的 rtsp 协议</p><ul><li>海康威视: rtps://admin:password@ip:port/h264/ch1/sub/av_stream</li><li>大华: rtps://admin:password@ip:port/cam/realmonitor?channel=1&amp;subtype=0</li><li>天地伟业: rtps://admin:password@ip:port/1/1</li><li>科达: rtps://admin:password@ip:port/id=1</li><li>华易明新: rtps://admin:password@ip:port/ch3</li></ul><p><strong>示例:</strong></p><p>node 端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FFMpeg 命令参数设置</span></span><br><span class="line"><span class="comment">// ffmpeg - i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -fflags nobuffer -vcodec libx264 </span></span><br><span class="line"><span class="comment">// -preset superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span></span><br><span class="line"><span class="keyword">let</span> ffmpeg = <span class="built_in">require</span>(<span class="string">'fluent-ffmpeg'</span>)</span><br><span class="line"><span class="keyword">let</span> running = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> command = ffmpeg(uri)</span><br><span class="line">    .outputOptions([</span><br><span class="line">        <span class="string">'-fflags'</span>,</span><br><span class="line">        <span class="string">'nobuffer'</span>,</span><br><span class="line">        <span class="string">'-vcodec'</span>,</span><br><span class="line">        <span class="string">'libx264'</span>,</span><br><span class="line">        <span class="string">'-preset'</span>,</span><br><span class="line">        <span class="string">'superfast'</span>,</span><br><span class="line">        <span class="comment">// '-rtsp_transport',</span></span><br><span class="line">        <span class="comment">// 'tcp',</span></span><br><span class="line">        <span class="comment">// '-threads',</span></span><br><span class="line">        <span class="comment">// '4',</span></span><br><span class="line">        <span class="string">'-f'</span>,</span><br><span class="line">        <span class="string">'flv'</span>,</span><br><span class="line">        <span class="string">'-r'</span>,</span><br><span class="line">        <span class="string">'15'</span>,</span><br><span class="line">        <span class="string">'-s'</span>,</span><br><span class="line">        <span class="string">'1280x720'</span>,</span><br><span class="line">        <span class="string">'-an'</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">// 此处的 /live/camera, camera类似于一个房间的概念, 你可以设置为你想要的名字</span></span><br><span class="line">    .save(<span class="string">`rtmp://<span class="subst">$&#123; nginxHost &#125;</span>:<span class="subst">$&#123; nginxPort &#125;</span>/live/camera`</span>)</span><br><span class="line">    .on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stream is start: '</span> + e)</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ffmpeg is end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ffmpeg is error! '</span>+ err)</span><br><span class="line">        reloadStream(uri)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reloadStream = <span class="function">(<span class="params">uri, userAgents</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!uri) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> userAgent = userAgents</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        command.kill()</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command._inputs[<span class="number">0</span>]) &#123;</span><br><span class="line">            command._inputs[<span class="number">0</span>].source = uri</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            command.input(uri)</span><br><span class="line">        &#125;</span><br><span class="line">        command.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> camFactory = &#123;</span><br><span class="line">    <span class="comment">// 海康</span></span><br><span class="line">    <span class="string">'0'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'h264/ch1/sub/av_stream'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 大华</span></span><br><span class="line">    <span class="string">'1'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'cam/realmonitor?channel=1&amp;subtype=0'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 天地伟业</span></span><br><span class="line">    <span class="string">'2'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1/1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 科达</span></span><br><span class="line">    <span class="string">'3'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'id=1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 华易明新</span></span><br><span class="line">    <span class="string">'4'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ch3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connection'</span>)</span><br><span class="line">    <span class="keyword">let</span> cameraInfo = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (cameraInfo.cameraName) &#123;</span><br><span class="line">        socket.emit(<span class="string">'CameraInfo'</span>, cameraInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取网络摄像头信息</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.cameraName === data.cameraName || cameraInfo.ip === data.ip) <span class="keyword">return</span></span><br><span class="line">        cameraInfo = data</span><br><span class="line">        cameraInfo.factory = data.factory || <span class="string">'0'</span></span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.RTSP&#125;</span>/<span class="subst">$&#123;camFactory[cameraInfo.factory]()&#125;</span>`</span></span><br><span class="line">        reloadStream(uri, data.userAgent)</span><br><span class="line">        socket.emit(<span class="string">'CameraInfo'</span>, cameraInfo)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'disconnect'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'end'</span>, _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'socket-io end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    socket.on(<span class="string">'err'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>FFmpeg 的参数对视频推流的画面质量和延迟有较大影响, 以下对我用过的 FFmpeg 参数作一些说明.如果使用海康摄像机 rtsp 转 rtmp 是可以直接使用 <code>copy</code> 参数性能会提高很多, 剩去了 FFmpeg 编码解码的过程. 下面的例子是当时的项目要兼容的华易明新的摄像机, 所以没有使用 <code>copy</code> 参数</p><p><strong>延迟影响相关参数(以下测试都在海康威视和华易明新摄像机测试):</strong></p><ol><li><p>fast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset fast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> fast 参数延迟表现较为不明显</p></li><li><p>superfast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset  superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> superfast 参数表现为 2-3 秒延迟, 但是画质会下降一点</p></li><li><p>ultrafast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset  ultrafast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> ultrafast 参数在我实验中表现跟 superfast 的延迟差距不是特别大, 大概在 1-2 秒左右, 画质会下降的比较明显</p></li><li><p>zerolatency 和 ultrafast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -tune zerolatency </span><br><span class="line">-vcodec libx264 -preset  ultrafast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> 讲道理第一个参数是零延迟, 但是添加这个参数之后在天桥部署的摄像机花屏会非常严重</p></li><li><p>nobuffer 和 superfast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -fflags nobuffer</span><br><span class="line"> -vcodec libx264 -preset  superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> nobuffer 参数表示不使用缓存, 在以上实验中华易明新摄像机在解码中丢包非常严重, nobuffer 参数在解码跟不上发送时放弃缓存, 所以最终选用 nobuffer + superfast 参数达到一个平衡的状态. </p></li></ol><p><strong>其他参数</strong></p><ul><li><p>rtsp_transport 参数: 传输方式, tcp/udp 两种, 默认为 udp.</p><p>  本来 udp 的传输方式更快消耗的资源也更少, 但是项目中反而改成 tcp 的方式效果更好</p></li><li><p>threads 参数</p><p>  threads 也是讲道理应该是解码线程数多一点效果好, 反而项目中将线程数减少效果更佳</p></li></ul><p>以上两个参数是我没理解的部分, 当然也可能是当时项目的环境有所影响. 这个项目也有一点奇怪的地方在这儿一起说, 在启动 FFmpeg 转码时电脑会蓝屏. 最终排查到的问题是: 1. CPU 启用涡轮加速 2. flash 开启硬件加速 3. ffmpeg 版本 4. 华易明新摄像机</p><p>解决方法: </p><ol><li>CPU 涡轮加速关闭</li><li>flash 关闭硬件加速 (据说是 flash 本身实现硬件加速不好) </li><li>将 FFmpeg 版本换至最新</li><li>更新摄像机硬件包</li></ol><p>蓝屏的这个问题只在一台电脑上遇见过特殊性比较高, 仅供参考.</p><p>nginx 配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 服务端口(默认端口)</span><br><span class="line">        listen 1935;</span><br><span class="line">        # 直播</span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- Old version compatible with flash --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;link href="//vjs.zencdn.net/5.19/video-js.min.css" rel="stylesheet"&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src="//vjs.zencdn.net/5.19/video.min.js"&gt;&lt;/script&gt;   --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- New version uncompatible with flash --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://vjs.zencdn.net/6.2.4/video-js.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://vjs.zencdn.net/6.2.4/video.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./videojs-flash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> videojs.options.flash.swf = <span class="string">'./video-js.swf'</span>; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"my-player"</span> <span class="attr">class</span>=<span class="string">"video-js"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"rtmp://127.0.0.1:1935/live/camera"</span> <span class="attr">type</span>=<span class="string">"rtmp/mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  videojs(<span class="string">'my-player'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    controls: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    autoplay: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">    flash: &#123;</span></span><br><span class="line"><span class="javascript">      swf: <span class="string">'./video-js.swf'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    height: 300,</span></span><br><span class="line"><span class="undefined">    width: 300</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充一句在 vue 中使用可以试试 <a href="https://github.com/surmon-china/vue-video-player" target="_blank" rel="noopener">vue-video-player</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一波网络摄像机的直播还是涨了很多姿势, 达成 FFmpeg 调参员. 不过在我离职之前还有一个问题一直没有解决, 客户端在运行 3-4 小时之后就会黑屏, 在刷新页面后又恢复. 我尝试过改 chrome 中 flash 的设置还是不行, 苟且了一点定时刷新暂时解决. 最终还是 flash 这个问题没法从根本上解决.</p><p>Created on 2017/7/26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于网络摄像机做视频预览这块, 本身其实是非常陌生的, 当时接到这个需求也是相当的头疼(对于当时一年经验不到的我来说).当时我们的应用场景是: 多路网络摄像机通过局域网连接, PC 端能够实时预览监控画面并且画质达到720p, 延迟不能超过10秒, 多个摄像机能够切换查看.
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://yoursite.com/tags/Node-js/"/>
    
      <category term="FFmpeg" scheme="https://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Babel生态</title>
    <link href="https://yoursite.com/2018/04/09/Babel/"/>
    <id>https://yoursite.com/2018/04/09/Babel/</id>
    <published>2018-04-09T09:55:20.000Z</published>
    <updated>2022-08-23T09:37:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 presets 以及 transform-runtime 和 babel-polyfill 的区别, 所以总结一下.</p><h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h3><p>我理解为 babel 的 command 全家桶, 用于在命令行操作的. 里面包含了 <code>babel</code>/ <code>babel-external-helpers</code>/ <code>babel-node</code> 3个命令</p><ul><li>babel: 用于编译代码</li><li>babel-external-helpers: 用于生成一些 halper 函数, 包含 babel 所有的 hepler 函数 (如: toArray 函数, jsx 转化函数). 这些函数实在 babel transform 的时候用, 都放在 <code>babel-helpers</code> 这个包中, 当这些 helpers 被用到就会被放置在生成代码的顶部. 但是当多个文件都用到了 helpers 函数就会产生冗余代码, 所以 babel 提供这个命令生成一个包含所有 helpers 的 js 文件用于直接引用.(然后可以通过 plugin 去检查全局时候存在这个模块, 存在就不定义)</li><li>babel-node: 主要是实现在 node 中写代码和执行脚本的能力, 可以直接运行 ES6代码. 比如直接在 node 中写 jsx, 通过这个就可以执行. 但是要把它编译成可执行的脚本还需要 <code>babel-register</code></li></ul><p>安装<br><code>npm install --global babel-cli</code></p><p>用法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">babel example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 转码结果写入文件</span><br><span class="line">babel example.js -o result.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 整个目录转码</span><br><span class="line">babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成 source map 文件</span><br><span class="line">babel src -d lib -s</span><br></pre></td></tr></table></figure></p><p>全局环境下 babel 无法支持不同版本的 babel, 所以安全的做法还是把 babel 装在项目中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure></p><p>package.json 改成:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"babel src -d lib"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>babel-register</strong><br>它的特点就是实时编译, 不会输出文件, 用来改写 <code>require</code> 命令为它加上钩子. <code>require</code> 进来的文件就会被转码, 但是它不会转码当前文件中的代码.</p><p>安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-register</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先加载 register</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>)</span><br><span class="line"><span class="comment">// 然后 register 就会对 test.js 文件转码</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'test.js'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>由于 <code>babel-register</code> 是即时转码, 所以只适用于开发环境使用.</p></blockquote><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p><code>babel-core</code> 可以说是 babel 最为核心的一个包, 可以把它看成一个编译器, babel 核心的 API 都在里面. 比如: transform 处理转码, 因为 ES6 的语法跟老语法不同, 所以先将我们的代码转换为 AST(抽象语法树), 然后分别做处理转化为 ES5. webpack 的 babel-loader 就是调用这些 API 完成转译的. <a href="https://babeljs.cn/docs/usage/api/" target="_blank" rel="noopener">这里是详细的 API</a></p><blockquote><p>这里需要注意的是: <code>babel-core</code> 仅关注 code transform, 也就是说它只做语法上的转换, 比如箭头函数. 所以并不是什么都能用 babel 来转换的, 如果涉及到新的 API 就需要你用 polyfill 来转译, 比如 <code>Promise</code>.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整块引入</span></span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line"><span class="comment">// 也可以选择某个 API 单独使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; transform &#125; <span class="keyword">from</span> <span class="string">'babel-core'</span></span><br></pre></td></tr></table></figure><p>主要的 API:</p><p><strong>babel.transform(code: string, options?: Object)</strong><br>将传入的 code 做转换, 返回值为一个对象, 参数为: 生成的对象, source map 和 AST</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = babel.transform(<span class="string">"code();"</span>, options);</span><br><span class="line">result.code</span><br><span class="line">result.map</span><br><span class="line">result.ast</span><br></pre></td></tr></table></figure><p><strong>babel.transformFile(filename: string, options?: Object, callback: Function)</strong><br>异步转译文件中的所有内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result <span class="comment">// &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>babel.transformFileSync(filename: string, options?: Object)</strong><br><code>babel.transformFile</code> 的同步版本, 返回值为 <code>filename</code> 文件中转译后的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFileSync(filename, options) <span class="comment">// &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure><p><strong>babel.transformFromAst(ast: Object, code?: string, options?: Object)</strong><br>反转译, 给一个 AST 转为 code</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">'if (true) return'</span></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code, &#123; <span class="attr">allowReturnOutsideFunction</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; code, map, ast &#125; = babel.transformFormAst(ast, code, options)</span><br></pre></td></tr></table></figure><h3 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h3><p><a href="https://babeljs.cn/docs/plugins/transform-runtime/" target="_blank" rel="noopener"><code>babel-runtime</code></a> 这个包其实就是把 core-js 和 regenerator 组合起来供使用, 它和 <code>babel-polyfill</code> 的都是为了模拟 ES6 环境. 之前提到的 <code>babel-core</code> 只对语法进行转换, 但不支持 Promise, Set, Map, array.reduce, Array.form, genertor, async 这些新 API 的编译, 所以才会用到这两个东西.</p><p><strong>core-js</strong>: 主要实现了 Promise, Symbols, ES7提案等等的 polyfill, 包含了大部分的 JavaScript 最新标准的垫片.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要单个引用后再使用</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/array/reduce'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>regenerator</strong>: 主要实现 generator/yeild, async/await (不知道为啥 core-js 不把这两个一起实现了…)</p><p><strong>helpers</strong>: <code>babel-runtime</code> 里也有 helpers, 它里面的 helpers 相当于之前提到的 <code>babel-external-helpers</code> 生成的 helpers.js, 只不过把每个 helpers 函数都单独放到一个文件夹里而已. 这样配合 transform 的时候, 需要用到 helpers 函数就可以直接从 <code>babel-runtime</code> 中引用了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _asyncToGenerator2 = <span class="built_in">require</span>(<span class="string">'babel-runtime/helpers/asyncToGenerator'</span>)</span><br></pre></td></tr></table></figure></p><p>区别: </p><ul><li><a href="https://babeljs.cn/docs/usage/polyfill" target="_blank" rel="noopener">babel-polyfill</a>: 是通过全局对象和内置对象的 prototype 上添加方法来达到目的, 所以一旦引入 <code>babel-polyfill</code> 就会污染全局环境.</li><li>babel-runtime: <code>babel-runtime</code> 是一个模块, 所以它不会污染全局环境和内置对象的原型. 它的做法引入需要的 helper 函数(类似: <code>const Promise = require(&#39;babel-runtime/core-js/promise&#39;)</code> 来引入 Promise).</li></ul><p>优缺点:</p><ul><li>babel-poly-fill: 引入一劳永逸, 但是污染环境.</li><li>babel-runtime: <ol><li>手动引入不方便</li><li>直接在代码中引入 helper 函数意味着不能共享, 最终打包出来会有很多冗余代码(引入的都是全量的 polyfill). </li></ol></li></ul><p>所以要配合 <code>babel-plugin-transform-runtime</code> (很多地方都是把 <code>babel-runtime</code> 和 <code>babel-plugin-transform-runtime</code> 统称为 transform-runtime, 因为它俩得合在一起才好用) 来达到按需引入 helper 避免重复打包和手动引入的痛苦, 它主要是做一层映射: 将 <code>babel-runtime</code> 内引用到的 core-js 或 regenerator.js 映射到具体对应的 helper. </p><blockquote><p>注意: <code>babel-runtime</code> 无法转码实例方法, 即内置对象原型上的方法, 只能通过 <code>babel-polyfill</code> 来转码. 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.find()</span><br><span class="line"><span class="string">'hello'</span>.includes(<span class="string">'h'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>另外, 关于为什么 <code>babel-runtime</code> 是 dependencies 依赖, 因为他只是集合了 polyfill 的一个 library, 对应需要的 polyfill 都是要引入项目中, 并跟项目代码一起打包的.</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h3><p>它能根据当前的运行环境, 自动确定你需要的 plugins 和 polyfills, babel 的配置官方推荐是写到 <code>.babelrc</code> 文件中, 以 <code>Vue-cli</code> 的 babel 配置为例.<a href="https://babeljs.cn/docs/plugins/preset-env/" target="_blank" rel="noopener">详细参数设置及说明</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, </span><br><span class="line">      &#123; </span><br><span class="line">        "modules": false // 设置 ES6 模块转译的模式, 默认是 commonjs</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 需要支持到哪个阶段的 JavaScript 版本</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  // 需要的插件</span><br><span class="line">  "plugins": [</span><br><span class="line">    "transform-runtime", // 虽然这里没有写 babel-runtime, 但是 transform-runtime 依赖于它, 所以还是要安装</span><br><span class="line">    <span class="string">"transform-vue-jsx"</span></span><br><span class="line">  ],</span><br><span class="line">  // 编译过程是否保留注释</span><br><span class="line">  "comments": false,</span><br><span class="line">  "env": &#123;</span><br><span class="line">    "test": &#123;</span><br><span class="line">      "presets": ["env", "stage-2"],</span><br><span class="line">      "plugins": [ "istanbul"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来 <code>babel-preset-env</code> 中有一个 useBuiltIns 选项(默认值是 false), 就是它实现的根据运行环境并判断需要什么 polyfill, 达到按需引入而不是整个引入, 对于 <code>import &#39;babel-polyfill&#39;</code> 就很棒了. 但是可以看到 vue-template 并没有使用这个选项, 这是因为   <a href="javascript:" title="我消不掉这个超链接😑" target="_blank" rel="noopener">babel-preset-env@1.x</a> 的版本没有办法很好消除未使用的 polyfill, 在2.x 版本下可以用 <code>usebuiltIns: &#39;usage&#39;</code>达到目的.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>babel 还有很多相关的东西没说到, 只挑了几个最重要的来说, 具体的 helpers/ plugins 都可以到<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">官方仓库</a>查看</p><ul><li><a href="https://github.com/babel/babel/tree/master/packages/babylon" target="_blank" rel="noopener">badylon</a>: 词法解析器</li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="noopener">babel-traverse</a>: 用于遍历, 维护整个 AST 的状态</li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="noopener">babel-generator</a>: 根据 AST 生成代码</li></ul><h4 id="babel-的工作流程"><a href="#babel-的工作流程" class="headerlink" title="babel 的工作流程"></a>babel 的工作流程</h4><p>输入需要转码的代码 -&gt; badylon 解析 -&gt; 得到 AST -&gt;<br>babel-traverse 遍历转译 -&gt; 得到新的 AST -&gt;<br>最后 babel-generator 根据新的 AST 生成代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个来说我觉得还是 <code>babel-runtime</code> 和 <code>babel-polyfill</code> 比较难区分, 其实两者的核心都在于 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 只是各有优缺点而已, 下面会再简要总结一下区别. 其他的话只需要知道每个东西是干啥的就行了.</p><ul><li>babel-polyfill: 污染环境, 支持实例方法(如果只想引入一些特定的polyfill, 那就去 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 中找相应的方法自己手动 require 进来); </li><li>runtime: 按需引用,不支持实例方法.</li></ul><p>Created on 2018-4-11 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 pre
      
    
    </summary>
    
    
      <category term="Babel" scheme="https://yoursite.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://yoursite.com/2018/04/02/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://yoursite.com/2018/04/02/跨域/</id>
    <published>2018-04-02T09:01:24.000Z</published>
    <updated>2022-08-23T09:37:40.693Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这块是前后端分离必经的一条路, 这次好好整理一下关于跨域方面知识.</p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h3><p>跨域是受同源策略的影响而导致的, 指一个源下的资源试图操作另一个源下的资源.</p><blockquote><p>那么, 什么又是同源策略呢?<br>就是限制从一个源的资源如何与另一个源的资源交互, 用于隔离潜在的恶意文件, 保证文件的安全性. 所谓的同源是指: 协议/域名/端口 三者相同, 即使两个不同的域名指向同一个 IP 地址, 也非同源. 如果没有同源策略, 浏览器很容易受到 XSS/CSRF 等的攻击(XSS: 跨站脚本攻击;CSRF: 跨站请求伪造).</p></blockquote><p>同源策略将限制以下行为:</p><ul><li>Cookie/LocalStorage/IndexDB</li><li>DOM 无法获得</li><li>Ajax 请求无法发送</li></ul><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h4><p>它的特性是简单/ 兼容性好/ 改造小, 但是不支持 POST 请求. 原理是通过 <code>script</code> 标签放入回调函数, 服务端将返回数据塞入回调函数即可.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createScript = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    script.src = url</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入请求地址</span></span><br><span class="line">createScript(<span class="string">'http://www.example.com/api?callback=foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 服务端返回数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2. document.domain"></a>2. document.domain</h4><p>通过设置域名来访问 <code>Cookie</code> 和 操作 <code>iframe</code> 窗口, 此方案只适用于主域相同, 子域不同的场景.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 父窗口 (http://www.main.com/a.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">'iframe'</span> <span class="attr">src</span>=<span class="string">'http://www.child.main.com/b.html'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'main.com'</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.cookie = <span class="string">'test=hi'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">'admin'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子窗口 (http://www.child.main.com/b.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'example.com'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> parentMessage = <span class="built_in">document</span>.cookie</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.parent.user)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-window-location-hash"><a href="#3-window-location-hash" class="headerlink" title="3. window.location.hash"></a>3. window.location.hash</h4><p>通过修改 hash 值来传递参数, 修改 hash 值并不会刷新页面但字节数有限制.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口向子窗口写入 hash</span></span><br><span class="line"><span class="keyword">let</span> src = <span class="string">`<span class="subst">$&#123;childUrl&#125;</span>#test=hi`</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>).src = src</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口</span></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> meg = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子窗口向父窗口写入 hash</span></span><br><span class="line"><span class="built_in">window</span>.parent.href = <span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.parent.href&#125;</span>#world`</span></span><br></pre></td></tr></table></figure><h4 id="4-window-name"><a href="#4-window-name" class="headerlink" title="4. window.name"></a>4. window.name</h4><p>window.name 只要在同一个窗口, 无论是否同源前一个页面设置了这个属性, 后一个页面就能读取. 它可以支持2M 大小的值但是变化需要自己监听.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口 (http://www.main.com/a.html)</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    <span class="keyword">let</span> state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到跨域页面</span></span><br><span class="line">    iframe.src = url</span><br><span class="line"></span><br><span class="line">    iframe.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次代理也加载成功之后, 读取 name 属性</span></span><br><span class="line">            callback(<span class="built_in">window</span>.name)</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//  第一次跳转到代理页面</span></span><br><span class="line">            iframe.src = <span class="string">'http://www.main.com/proxy.html'</span></span><br><span class="line">            state = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入跨域页面 URL</span></span><br><span class="line">proxy(<span class="string">'http://www.child.com/b.html'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// 'This message from b.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域子窗口 (http://www.child.com/b.html) </span></span><br><span class="line"><span class="comment">// 设置 name 属性</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'This message from b.html'</span></span><br></pre></td></tr></table></figure><h4 id="5-postMessage"><a href="#5-postMessage" class="headerlink" title="5. postMessage"></a>5. postMessage</h4><p>postMessage(跨文档通信) 是 HTML5 中为了解决跨域出的 API, 可以解决以下几种问题:</p><ol><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ol><p>发送消息通过 <code>postMessage(data, origin)</code> 方法, 该方法接收两个参数: </p><ul><li>data: 需要传递的参数, 由于部分浏览器只支持字符串, 所以传递之前最好先 <code>JSON.stringify()</code> 序列化</li><li>origin: 是接收方的 协议 + 主机 + 端口, 可以是设置为 <code>*</code>, 指定与当前窗口同源的话设置为 <code>/</code>.</li></ul><p>接收消息通过 <code>message</code> 事件监听, 该事件有一个 <code>event</code> 参数提供三个属性:</p><ul><li>event.origin: 消息接收方</li><li>event.source: 消息来源</li><li>event.data: 消息体</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 父窗口 (http://www.main.com/a.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">firame</span> <span class="attr">id</span>=<span class="string">'iframe'</span> <span class="attr">src</span>=<span class="string">'http://www.child.com/b.html'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> url = iframe.src</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">'parent'</span>,</span></span><br><span class="line"><span class="javascript">            message: <span class="string">'This message from parent'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 跨域向子窗口发送消息</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), url)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 父窗口监听子窗口发送的消息</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 过滤不属于自己的消息</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (data.origin !== <span class="string">'http://www.main.com/a.html'</span>) <span class="keyword">return</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from child: '</span> + event.data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子窗口 (http://www.child.com/b.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from main: '</span> + event.data)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(event.data)</span></span><br><span class="line"><span class="javascript">        data.name = <span class="string">'child'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 收到消息后处理再发送给父窗口</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.main.com/a.html'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-CORS"><a href="#5-CORS" class="headerlink" title="5. CORS"></a>5. CORS</h4><p>跨域资源共享(Cross-origin-resource-sharing), 它允许浏览器向跨源服务器发出 <code>XMLHttpRequest</code> 请求. CORS 现在也是主流的跨域解决方案, 这种方式只需要后端做处理, 如果要带上 cookie 那么前后端都要设置.</p><p>带 cookie 传输:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>请求实例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> XMLRequest = <span class="function">(<span class="params">method = <span class="string">'GET'</span>, url = <span class="string">''</span>, data = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>)</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">    xhr.send(data)</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XMLRequest(<span class="string">'POST'</span>, <span class="string">'http://www.example.com/api'</span>, &#123;</span><br><span class="line">    name: <span class="string">'cara'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中 <code>readyState</code> 有五种状态:<br>0: 为初始化<br>1: 服务器连接建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成</p><h4 id="6-代理服务器"><a href="#6-代理服务器" class="headerlink" title="6. 代理服务器"></a>6. 代理服务器</h4><p>其实就是通过配置 nginx 实现一个中间服务器作跳板, 代理到目标服务器.</p><p>静态资源代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体代理配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 81;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line"></span><br><span class="line">    lication / &#123;</span><br><span class="line">        # 反向代理</span><br><span class="line">        proxy_pass http://www.example2.com:8080;</span><br><span class="line">        # 修改 cookie 域名</span><br><span class="line">        proxy_cookie_domain www.example2.com www.example.com;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 不带 cookie 时才能设置为 *</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.example.com;</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'htt://www.example.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p><p>以上, 就是跨域导致的原因以及解决方案的大致总结.</p><p>Created on 2018-4-2 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跨域这块是前后端分离必经的一条路, 这次好好整理一下关于跨域方面知识.&lt;/p&gt;
&lt;h3 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域?&quot;&gt;&lt;/a&gt;什么是跨域?&lt;/h3&gt;&lt;p&gt;跨域是受同源策略的影响而导
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise 分析及实现</title>
    <link href="https://yoursite.com/2018/01/04/Promise-%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yoursite.com/2018/01/04/Promise-分析及实现/</id>
    <published>2018-01-04T11:07:22.000Z</published>
    <updated>2022-08-23T09:37:40.690Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是 ES6中中收录的异步操作封装, 通常在回调/ 事件/ 消息等异步操作中有显著的优势, 让我们在更方便的操作异步也让代码更加清晰.包括 ES7中的 Async/Await 也是对异步操作的封装, 不过 Async 更像是 Generator 的语法糖.</p><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>学习<a href="https://tech.meituan.com/promise-insight.html" target="_blank" rel="noopener">剖析 Promise 之基础篇</a>用一个最常见的应用来剖析 <code>Promise</code>, 通过异步获取用户 Id, 然后作一些处理. 平常我们最常用的是回调的方式来处理, 下面用 <code>Promise</code> 的方式来处理.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        axios.get(<span class="string">'http://example.com/api'</span>, <span class="attr">params</span>: param).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(res).id)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getUserId().then(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id)</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>getUserId 函数返回一个 <code>Promise</code>, 在他的 <code>then</code> 方法中放入异步操作成功之后的回调函数. 这种方式明显比我们之前常用的回调函数更加方便而且易读, 也更加容易避免 callback hell.</p><p>那么满足这样的场景的<code>Promise</code>是怎样实现的呢, 下面我们可以简单的实现一下最基础的<code>Promise</code>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 存入异步成功需要的回调函数</span></span><br><span class="line">    <span class="comment">// 此时指向两个回调函数 id =&gt; &#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        deferreds.push(onFulfilled)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 执行 deferreds 队列中的回调函数</span></span><br><span class="line">    <span class="comment">// 此时 value 为123</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">            deferred(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 执行创建 Promise 实例时传入的函数</span></span><br><span class="line">    <span class="comment">// 并传入 resolve 供在适当时触发回调</span></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 执行 resolve</span></span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getUserId().then( <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is callback!'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(id) <span class="comment">// 123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is second callback!'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(id) <span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>调用 <code>then</code> 方法将回调函数存入 deferreds 队列.</li><li>创建 <code>Promise</code> 实例时传入函数和 <code>resolve</code>, <code>resolve</code> 用于在适当的时间触发回调函数.</li><li>真正执行回调函数的是 <code>deferreds</code> 队列中的元素.</li><li><code>resolve</code> 函数接受一个参数, 用于回调函数使用, 即异步操作的返回结果.</li></ul><p>可能大家已经发现, 以上代码并不能真正执行到回调函数.根据上面标注的序号就是代码的执行顺序, 这是因为现在还是同步函数, <code>Promise</code> 函数中的 <code>resolve</code> 函数会先于 <code>this.then</code> 函数执行,此时 <code>deferreds</code> 队列中还是空的, 以至于后面的回调函数也无法执行. 所以我们要保证回调以异步的方式执行, 以保证执行顺序. 可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中的回调函数放在执行栈的末尾.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将执行的回调的逻辑放入执行栈末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">            deferred(value)</span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在就可以看到, then 中的回调函数能够正常执行了.</p><h4 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h4><p>现在我们引入规范 <code>Promises/A+</code> 中所说的 States, 它有三个互斥的状态: pending/ fulfilled/ rejected.</p><p>现在我们来改进下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(onFulfilled)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        onFulfilled(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        value = newValue</span><br><span class="line">        state = <span class="string">'fulfilled'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">                deferred(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>串行 <code>Promise</code> 是指当 promise 达到 fuifilled 状态之后, 再进行下一个 promise. 比如上例中的我们拿到 userId 之后还需要用这个 userId 去获取用户的名称/ 住址/ 手机号等其他信息.</p><p>使用的伪代码类似这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">getUserId()</span><br><span class="line">    .then(getUserInfoById)</span><br><span class="line">    .then(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> getUserInfoById = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        axios.get(<span class="string">'http://example.com/api'</span>, <span class="attr">params</span>: &#123;</span><br><span class="line">            id: <span class="number">123</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(response).info)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>串行的困难在于如何将前后的 <code>Promise</code> 衔接起来, 首先对 <code>then</code> 方法改造:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// bridge promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        handle(&#123;</span><br><span class="line">            onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">            resolve: resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = <span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        deferreds.push(deferred)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = deferred.onFulfilled(value)</span><br><span class="line">    deferred.resolve(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>then</code> 方法中返回一个新创建的 Promise 实例作为返回值, 这是串行的基础, 由于返回类型一样所以依然支持链式.</li><li><code>then</code> 方法中的形参 <code>onFulfilled</code> 和新创建的 Promise 实例中的 <code>resolve</code> 均放入当前 promise 的 deferreds 队列中.</li><li><code>handle</code> 方法作为当前 promise 的内部方法, 较之前的 <code>then</code> 方法只增加了一行<code>deferred.resolve(ret)</code>.</li></ul><p>在当前 promise 的异步成功之后执行 <code>handle</code> 方法时, 先执行 <code>onFulfilled</code> 方法, 然后将其返回值作为 <code>resolve</code> 方法的实参传入.</p><p>再改造 <code>resolve</code> 方法, 把代码整理一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 Promise作为返回值</span></span><br><span class="line">        <span class="comment">// 将当前 promise 的回调函数和新创建的 resolve</span></span><br><span class="line">        <span class="comment">// 放入 deferreds 队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled: onFulfilled || <span class="literal">null</span></span><br><span class="line">                resolve: resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化状态时, 往 deferreds 队列添加</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(deferred)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 promise 达到 'fulfilled' 状态之后</span></span><br><span class="line">        <span class="comment">// 先执行回调函数, 再将回调函数的返回值(ret)</span></span><br><span class="line">        <span class="comment">// 传递给 resolve 函数</span></span><br><span class="line">        <span class="keyword">let</span> ret = deferred.onFulfilled(value)</span><br><span class="line">        deferred.resolve(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> then = newValue.then</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(newValue, resolve)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        value = newValue</span><br><span class="line">        state = <span class="string">'fulfilled'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">                handle(deferred)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 promise 实例中的回调函数</span></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserId()</span><br><span class="line">    .then(getUserInfoById)</span><br><span class="line">    .then(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is second callback'</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>现在 <code>resolve</code> 支持传入一个 promise 实例的参数了, 执行顺序如下:</p><ol><li><code>getUserId</code> 生成的 promise1, 进入 Promise 函数执行 <code>fn(resolve)</code> 由于<code>getUserId</code> 的内部是一个异步操作, 下一步会直接执行 <code>this.then(onFulfilled)</code>.</li><li><code>this.then()</code> 返回一个新的 promise2 函数( 即: bridge promise)作为链式调用, promise2 重新实例化再执行 <code>fn(resolve)</code>, 则进入<code>handle({...})</code> 此时 handle 的参数为 getUserInfoById 和 resolve2, 接着被 push 到 <code>deferreds1</code> 队列中; 再接着执行下一个<code>this.then()</code> 生成 promise3, <code>deferreds2</code> 队列中 push 进第二个 then 的匿名函数(userInfo =&gt; {…}) 和 resolve3.</li><li>执行<code>resolve(123)</code>, 进入 <code>resolve(newValue)</code> 执行<code>handle(deferred)</code> 此时 deferred 为 getUserInfoById 和 resolve2, 执行 handle 内部的 <code>deferred.onFulfilled(value)</code> 也就是 getUserInfoById 方法从而生成 promise4, 再到 <code>deferred.resolve(ret)</code> 这个时候 ret 就为 promise4, 传入 <code>resolve(newValue)</code> 执行 <code>then.call(promise4, resolve2)</code>.</li><li>接着上一步进入 <code>this.then()</code> 生成 promise5(bridge promise), deferred4 压入 resolve2 和 resolve5; 在执行 getUserInfoById 中的 <code>resolve({name: &#39;cara&#39;...})</code>, 进入 setTimeout 中的 <code>handle(deferred)</code>, 到 handle 函数内部 <code>deferred.onFulfilled(value)</code> 其实执行的是 <code>resolve2({...})</code> resolve2中的 <code>deferred</code> 保存的是的 <code>uerInfo =&gt; {}</code> 匿名函数和 <code>resolve3</code>; <code>deferred.resolve</code> 其实执行的是 <code>resolve5</code>, 由于 resolve3 和 resolve5 中的 <code>deferred</code> 都是空的于是完成整个流程.</li></ol><p>接下来再加入错误处理和异常判断:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">'pending'</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        deferreds = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">                onRejected: onRejected || <span class="literal">null</span>,</span><br><span class="line">                resolve: resolve,</span><br><span class="line">                reject: reject</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(deferred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cb = state === <span class="string">'fulfilled'</span> </span><br><span class="line">            ? deferred.onFulfilled </span><br><span class="line">            : deferred.onRejected,</span><br><span class="line">                ret;</span><br><span class="line">        <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">            cb = state === <span class="string">'fulfilled'</span> </span><br><span class="line">                ? deferred.resolve </span><br><span class="line">                : deferred.reject;</span><br><span class="line">            cb(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = cb(value);</span><br><span class="line">            deferred.resolve(ret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            deferred.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(newValue, resolve, reject);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        value = newValue;</span><br><span class="line">        finale();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        state = <span class="string">'rejected'</span>;</span><br><span class="line">        value = reason;</span><br><span class="line">        finale();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            deferreds.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">                handle(deferred);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>之前的文字描述不好理解, 所以还是画了一个执行流程图</strong><br><img src="/img/Promise执行过程.png" alt="promise执行过程"></p><p>没有画 <code>reject</code> 的情况, 因为<code>reject</code> 跟 <code>resolve</code> 的流程是一样的, 两个一起画显得更乱就单独把 <code>resolve</code> 拎出来. 在加入 <code>handle</code> 和 <code>resolve</code> 在 promise 函数中作为内部方法后实在不易理解. 主要就是通过闭包来保存 promise 对象的变量引用, 将回调函数和 resolve 函数保存在缓存队列中, 在通过 resolve 完成链式调用.</p><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><p>看完之前的那篇文章实在觉得有点难理解, 于是又找了其他的实现方式<a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="noopener">JS Promise的实现原理</a>比之前那篇更好理解一些, 所以还是记录一下好了.</p><blockquote><p>这篇文章作者说到的 <code>Promise</code> 重点:</p><ol><li><code>Promise</code> 是一个承诺, 所以不管成功与否都要有一个执行结果, 因此 Promise 构造函数有一个函数类型的参数 <code>resolver</code> 来作为与该 promise 对象关联的任务.</li><li>三种状态不可逆转.</li><li><code>resolver</code> 函数封装了需要执行的异步操作, 内部: <code>resolve</code> 和 <code>reject</code> 两个参数; 分别代表执行成功和执行失败需要执行的操作.</li><li><code>then</code> 提供成功或失败的响应处理, 于是有了<code>onResolve</code> 和 <code>onReject</code>.</li><li><code>then</code> 方法返回一个新的 promise(bridge promise), 提供链式操作及串行, 如果直接返回 this 那么就是并行显然不符合我们的需求. 前一个 promise 需要知道下一个 promise 对象是谁及其任务引用, 而后一个 promise 要提供一个给前一个 promise 成功或失败时需要执行的任务, 因此添加一个闭包</li><li><code>makeCallback</code> 调用将 promise 及其关联任务传递进去, 返回一个新函数, 前一个 promise 对象就将持有返回函数的引用, 调用返回函数时就能访问到 promise 对象和关联任务.</li><li><code>resolve</code> 和 <code>reject</code> 函数在异步成功或失败的时候调用, 并传递成功的数据和失败的原因.</li><li><code>run</code> 函数执行异步相关的回调函数.</li></ol></blockquote><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功队列</span></span><br><span class="line">    <span class="keyword">this</span>._doneCallbacks = []</span><br><span class="line">    <span class="comment">// 失败队列</span></span><br><span class="line">    <span class="keyword">this</span>._failCallbacks = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递关联任务</span></span><br><span class="line">    resolver(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>then</code> 方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolve, onReject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 添加闭包调用</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存对上一个 promise 的引用</span></span><br><span class="line">    <span class="keyword">this</span>._doneCallbacks.push(makeCallback(promise, onResolve, <span class="string">'reslove'</span>))</span><br><span class="line">    <span class="keyword">this</span>._failCallbacks.push(makeCallback(promise, onReject, <span class="string">'reject'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>makeCallback</code> 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 对象/ 回调函数(关联任务)/ 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span> (<span class="params">promise, callback, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>resolve</code> 函数和 <code>reject</code> 函数<br>这两个函数都需要一个参数来接收结果, 由于状态只能转换一次所以两个函数都需要判断状态.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="comment">// promise: 属于哪个 promise 对象</span></span><br><span class="line"><span class="comment">// data: 异步操作的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 已经被 resolve 过的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (promise._status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 promise 状态</span></span><br><span class="line">    promise._status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="comment">// 保存异步操作的值</span></span><br><span class="line">    promise._value = data</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行相关回调函数</span></span><br><span class="line">    run(promise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="comment">// promise: 属于哪个 promise 对象</span></span><br><span class="line"><span class="comment">// reason: 失败原因</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise._status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    promise._status = <span class="string">'rejected'</span></span><br><span class="line">    promise._value = reason</span><br><span class="line">    </span><br><span class="line">    run(promise)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>run</code> 函数<br>用来执行异步相关的回调函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then 方法中也会调用, 此处再做一次判断</span></span><br><span class="line">    <span class="keyword">if</span> (promise._status === <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> value = promise._value</span><br><span class="line">    <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="keyword">let</span> callbacks = promise._status === <span class="string">'fulfilled'</span></span><br><span class="line">        ? promise._doneCallbacks</span><br><span class="line">        : promise._failCallbacks</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里需要异步</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        callbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(value))</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    promise._doneCallbacks = []</span><br><span class="line">    promise._failCallbacks = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>run</code> 函数中的 callbacks 就是 <code>makeCallback</code> 所返回的函数</strong></p><ul><li>完善 <code>makeCallback</code> 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span> (<span class="params">promise, callback, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 callback 是个函数, 使用前一个 promise</span></span><br><span class="line">        <span class="comment">// 传递的值作为 callback 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> x</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x = callback(value)</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// 异常时, 用当前 promise 的 reject</span></span><br><span class="line">                reject(promise, e)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 callback 返回的是当前的 promise</span></span><br><span class="line">            <span class="comment">// 要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (x === promise) &#123;</span><br><span class="line">                <span class="keyword">let</span> reason = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error: return value could not be same with the promise'</span>)</span><br><span class="line">                reject(promise, reason)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果返回值是一个 promise 对象</span></span><br><span class="line">            <span class="comment">// 则当返回 promise 对象被 reoslve/ reject后</span></span><br><span class="line">            <span class="comment">// 再执行当前的 promise 的 resolve/ reject</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                x.then(</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        resolve(promise, data)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                        reject(promise, reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> then</span><br><span class="line">                (<span class="function"><span class="keyword">function</span> <span class="title">resolveThenable</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 如果返回的是一个 Thenable 对象</span></span><br><span class="line">                    <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            then = x.then</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(promise, e)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                            <span class="comment">// 调用 Thenable 对象的 then方法</span></span><br><span class="line">                            <span class="comment">// 传递进去的 resolvePromise 和 rejectPromise 以及下面两个匿名函数</span></span><br><span class="line">                            <span class="comment">// 可能会重复调用, 但是规范只能有其中一个被调用一次, 其他要被忽略</span></span><br><span class="line">                            <span class="keyword">let</span> invoked = <span class="literal">false</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                then.call(x,</span><br><span class="line">                                    <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">                                        <span class="keyword">if</span> (invoked) <span class="keyword">return</span></span><br><span class="line">                                        invoked = <span class="literal">true</span></span><br><span class="line">                                        </span><br><span class="line">                                        <span class="comment">// 避免两个 promise 恒等</span></span><br><span class="line">                                        <span class="keyword">if</span> (y === x) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error: return value could not be same with the promise'</span>)</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        </span><br><span class="line">                                    <span class="comment">// y 有可能还是 thenable 对象    </span></span><br><span class="line">                                    resolveThenable(y)</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                                        <span class="keyword">if</span> (invoked) <span class="keyword">return</span></span><br><span class="line">                                        invoked = <span class="literal">true</span></span><br><span class="line">                                        </span><br><span class="line">                                        reject(promise, e)</span><br><span class="line">                                    &#125;</span><br><span class="line">                                )</span><br><span class="line">                            &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                                    <span class="comment">// 如果`resolvePromise`和`rejectPromise`方法被调用后，再抛出异常，则忽略异常</span></span><br><span class="line">                                    <span class="comment">// 否则用异常对象reject此Promise对象</span></span><br><span class="line">                                <span class="keyword">if</span> (!invoked) &#123;</span><br><span class="line">                                    reject(promise, e)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            resolve(promise, x)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        resolve(promise, x)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;(x))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有传 callback直接使用前一个 promise</span></span><br><span class="line">        <span class="comment">// 传过来的值 resolve/reject 当前 promise 对象</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            action === <span class="string">'resolve'</span></span><br><span class="line">                ? resolve(promise, value)</span><br><span class="line">                : reject(promise, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我一开始是先看的<strong>剖析 Promise 之基础篇</strong>, 前半部分确实很亲民, 但是到加入 <code>hanlde</code> 和改造 <code>resolve</code> 函数 就开始懵了, 然后懵懵懂懂的去看<strong>JS Promise 的原理实现</strong>, 不过在最复杂的 <code>makeCallback</code> 函数中解释有点一笔带过的意思. 不过看了这篇帮助我理解之前的<strong>剖析 Promise 之基础篇</strong>, 就返回去看基础篇画了一遍流程图才算看懂, 里面的闭包用的太精妙了.</p><blockquote><p>参考文章<br><a href="https://tech.meituan.com/promise-insight.html" target="_blank" rel="noopener">剖析 Promise 之基础篇</a><br><a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="noopener">JS Promise 的原理实现</a><br><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构</a></p></blockquote><p>Created on 2017-12-26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise 是 ES6中中收录的异步操作封装, 通常在回调/ 事件/ 消息等异步操作中有显著的优势, 让我们在更方便的操作异步也让代码更加清晰.包括 ES7中的 Async/Await 也是对异步操作的封装, 不过 Async 更像是 Generator 的语法糖.&lt;/
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《图解 HTTP》(上)</title>
    <link href="https://yoursite.com/2018/01/03/HTTP-%E4%B8%8A/"/>
    <id>https://yoursite.com/2018/01/03/HTTP-上/</id>
    <published>2018-01-03T14:03:05.000Z</published>
    <updated>2022-08-23T09:37:40.689Z</updated>
    
    <content type="html"><![CDATA[<p>Web使用HTTP(HyperText Transfer Protocal) 超文本传输协议作为规范, 完成从客户端到服务端的一系列流程. 可以说 Web 是在 HTTP 协议上通信的.</p><h3 id="1-0-网络基础TCP-IP"><a href="#1-0-网络基础TCP-IP" class="headerlink" title="1.0 网络基础TCP/IP"></a>1.0 网络基础TCP/IP</h3><p>通常我们使用的网络是在 TCP/IP 协议族的基础上运行的, 而 HTTP 是属于 TCP/IP 族群中的一种协议. 在计算机和网络相互通信的时候, 两者都必须要遵守同一种协议.</p><h4 id="1-1-TCP-IP分层管理"><a href="#1-1-TCP-IP分层管理" class="headerlink" title="1.1 TCP/ IP分层管理"></a>1.1 TCP/ IP分层管理</h4><p>TCP/IP协议族里最重要的一点就是分层, 每一层就只需要专注于自己任务就行了, 按层次分别为以下四层:</p><ol><li><p>应用层<br>决定向用户提供应用服务时的通信活动, 在 TCP/IP 中预存了各类通用的应用服务. 比如: FTP(File Transfer Protocol, 文件传输协议)和 DNS(Domain Name System, 域名系统), HTTP 协议也属于这层.</p></li><li><p>传输层<br>给两个计算机在网络中提供数据传输. TCP(传输控制协议)和 UDP(用户数据报协议)</p></li><li><p>网络层<br>处理网上流动的数据包, 决定数据通过哪条传输路线到对方计算机并把数据传输给对方.</p></li><li><p>链路层<br>处理连接网络的硬件部分. 网卡/ 驱动/ 光纤什么的</p></li></ol><h4 id="1-2-TCP-IP-传输流程"><a href="#1-2-TCP-IP-传输流程" class="headerlink" title="1.2 TCP/IP 传输流程"></a>1.2 TCP/IP 传输流程</h4><p>TCP/IP 在网络通信时, 会按照分层顺序与对方通信. 发送端从应用层往下, 接收端从应用端网上.</p><p><img src="/img/http.jpg" alt="TCP/IP传输流程"></p><h3 id="2-0-与-HTTP-关系密切的协议-IP-TCP-和-DNS"><a href="#2-0-与-HTTP-关系密切的协议-IP-TCP-和-DNS" class="headerlink" title="2.0 与 HTTP 关系密切的协议: IP/TCP 和 DNS"></a>2.0 与 HTTP 关系密切的协议: IP/TCP 和 DNS</h3><ul><li>负责传输的 IP 协议<br>将数据包传递给对方并确认到达, 确认到达的重要条件包括: IP 地址和 MAC 地址.<br><img src="/img/ip.jpg" alt="IP"></li><li>确保可靠性的 TCP 协议<br>为了方便传输将大数据包分割成以报文段为单位的数据包进行管理, 再将数据准确可靠的传递给对方. 那么如何准确可靠的传递给对方呢, 所以就有了TCP 的三次握手策略: 发送端先发送一个带有 <code>SYN</code>标志的数据包给对方, 接收端回传一个带有<code>SYN/ACK</code>标志的数据包传达确认信息, 最后发送端再回传一个带有<code>ACK</code>标志的数据包, 代表握手结束.<br><img src="/img/tcp.jpg" alt="TCP"></li><li>负责域名协议的 DNS 服务<br>提供域名到 IP 地址之间解析服务.<br><img src="/img/dns.jpg" alt="DNS"></li></ul><h4 id="2-1-HTTP-协议的通信过程"><a href="#2-1-HTTP-协议的通信过程" class="headerlink" title="2.1 HTTP 协议的通信过程"></a>2.1 HTTP 协议的通信过程</h4><p>通过一整套流程来看一下, IP协议/ TCP协议 和 DNS服务在 HTTP协议的通信过程中各自发挥了什么作用.<br><img src="/img/HTTP_IP_TCP_DNS.jpg" alt="HTTP协议通信过程"></p><p><strong>从上图来看, 从输入一个网址到页面的展示过程大致如下:</strong></p><ol><li>域名解析(DNS 服务)</li><li>建立TCP, 发送 HTTP 请求(三次握手)<ol><li>客户端向服务器发送请求(SYN)</li><li>服务器应答并要求确认(SYN/ACK)</li><li>客户端确认(ACK)</li></ol></li><li>IP 搜索对方地址, 一边中转一边传输数据包</li><li>服务器处理请求返回 HTTP 响应报文</li><li>连接结束(四次挥手)<ol><li>客户端发送一个 FIN 来告诉服务器数据发送完毕</li><li>服务器收到这个 FIN 之后回发一个 ACK(这个时候服务器还可以向客户端发送数据)</li><li>服务器发送一个 FIN 告诉客户端服务器的数据发送完毕, 请求关闭连接</li><li>客户端回发 ACK 确认, 关闭连接</li></ol></li><li>浏览器解析渲染页面</li></ol><h4 id="2-2-HTTP-是否保存状态"><a href="#2-2-HTTP-是否保存状态" class="headerlink" title="2.2 HTTP 是否保存状态"></a>2.2 HTTP 是否保存状态</h4><p>HTTP 是一种不保存状态(无状态)协议, 协议本身不会保留之前的请求或响应报文的信息. 这是为了更快的处理大量请求, 但是随着 Web 发展<br>很多业务都需要保存用户的状态, 因此引入 Cookie 来管理状态.</p><h3 id="3-0-HTTP-返回状态码"><a href="#3-0-HTTP-返回状态码" class="headerlink" title="3.0 HTTP 返回状态码"></a>3.0 HTTP 返回状态码</h3><p>状态码是用来告诉客户端从服务器响应的请求结果, 可以通过状态码知道该次请求是正常处理了还是发生了错误.</p><h4 id="3-1-状态码的类别"><a href="#3-1-状态码的类别" class="headerlink" title="3.1 状态码的类别"></a>3.1 状态码的类别</h4><table><thead><tr><th></th><th style="text-align:left">类别</th><th style="text-align:left">原因短句</th></tr></thead><tbody><tr><td>1XX</td><td style="text-align:left">信息类</td><td style="text-align:left">接收的请求正在处理</td></tr><tr><td>2XX</td><td style="text-align:left">成功类</td><td style="text-align:left">请求正常处理完毕</td></tr><tr><td>3XX</td><td style="text-align:left">重定向类</td><td style="text-align:left">需要附加操作完成请求</td></tr><tr><td>4XX</td><td style="text-align:left">客户端错误类</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td>5XX</td><td style="text-align:left">服务器错误类</td><td style="text-align:left">服务器发生错误</td></tr></tbody></table><h4 id="3-2-具有代表性的14种状态码"><a href="#3-2-具有代表性的14种状态码" class="headerlink" title="3.2 具有代表性的14种状态码"></a>3.2 具有代表性的14种状态码</h4><ul><li>2XX 成功类<ol><li>200 OK<br>表示请求在服务端被正常处理了</li><li>204  No Content<br>表示请求处理成功但是响应报文不包含实体的主体(本身也不允许返回实体的主体)</li><li>206  Partial Content<br>服务端成功处理了客户端发出的范围请求</li></ol></li><li>3XX 重定向<ol><li>301 Moved Permanently<br>永久性重定向. 请求的资源已经被分配了新的 URI 应该使用新的 URI</li><li>302 Found<br>临时性重定向. 请求的资源被分配了新的 URI, 希望本次请求用新的 URI</li><li>303 See Other<br>请求的资源存在另一个 URI, 应使用 GET 方法定向获取请求的资源(跟302的功能相同)</li><li>304 Not Modified<br>表示请求时附带了条件, 服务端允许请求资源但为满足条件. 所以返回时, 不包含任何响应的主体部分(跟重定向并没有半毛钱关系).</li><li>307 Temporary Redirect<br>临时重定向, 跟302有着同样的一样. 尽管302标准不允许 POST 变为 GET, 但是并没有人遵守; 307会遵守标准但是处理响应时, 每个浏览器有可能出现不同的情况</li></ol></li><li>4XX 客户端错误<ol><li>400 Bad Request<br>请求报文中有语法错误</li><li>401 Unauthorized<br>请求需要通过 HTTP 认证</li><li>403 Forbidden<br>请求资源访问被服务端拒绝(一般都是权限问题)</li><li>404 Not Found<br>服务端上无法找到请求的资源</li><li>405 Not Allow<br>对于请求的资源, 服务端不允许使用请求中使用的方法</li></ol></li><li>5XX 服务器错误<ol><li>500 Internal Server Error<br>服务端在执行请求任务时发生错误</li><li>503 Service Unavailable<br>服务端暂时处于超负载或者停机维护, 无法处理请求(一般就是服务器挂了)</li></ol></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要为了大致了解一下 HTTP 的基础/大概的执行流程和常见的HTTP 状态码. 对于状态码之前一直分不太清301和302的区别, 简单的来说: 301 改变资源的URI 后, 如果这个资源是被保存在书签中的, 那么这时要根据新的 URI 保存; 302 表示这个资源只是临时性的移动, 之后这个 URI 可能还会变化. 那么如果也被保存在了书签中, 仍然会保留原来的 URI. 状态码中的 304 放在下次放在缓存策略中再捋一捋吧.</p><p>Create on 2018-1-3 By Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web使用HTTP(HyperText Transfer Protocal) 超文本传输协议作为规范, 完成从客户端到服务端的一系列流程. 可以说 Web 是在 HTTP 协议上通信的.&lt;/p&gt;
&lt;h3 id=&quot;1-0-网络基础TCP-IP&quot;&gt;&lt;a href=&quot;#1-0-网
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="网络" scheme="https://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>声明提升</title>
    <link href="https://yoursite.com/2017/12/20/%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    <id>https://yoursite.com/2017/12/20/声明提升/</id>
    <published>2017-12-20T13:54:07.000Z</published>
    <updated>2022-08-23T09:37:40.692Z</updated>
    
    <content type="html"><![CDATA[<p>在说声明提升之前, 首先应该了解三个概念性的东西, 执行上下文(Execution Context)/ 变量对象(Variable Object)和活动对象(Activation Object), 这三个概念是在 ES3 中出现的.</p><ul><li><p>执行上下文(Execution Context)<br>执行上下文也可以说是 js 代码的运行环境, 代码一旦被加载 js 的解释器首先进入的就是这个环境. 他有全局的执行上下文和函数的执行上下文(eval 不说, 它内部也有), js 的解释器默认先进入的是全局上下文所以我们一开始就能直接使用一些的内置方法, 比如: Array/ Number… 每当一个函数被调用时, 就会创建他自己的执行上下文, 每个执行上下文都有一个与之关联的变量对象.</p></li><li><p>作用域链(也称调用栈)<br>知道了每当一个函数调用时会创建自己的执行上下文, 这个执行上下文就会被添加到作用域链的顶端. 而解释器总是先运行作用域链顶端的执行上下文, 一旦函数调用完毕, 它的执行上下文就会从作用域链的顶端移除并将控制权交由上一个执行上下文, 直到回到全局上下文. 如下图所示:<br><img src="/img/event-loop.gif" alt="执行环境"></p></li></ul><ul><li>变量对象(Variable Object)<br>当执行上下文创建后, 进入建立阶段(函数调用, 具体代码执行之前), 在这个阶段变量对象/ 作用域链/ <code>this</code>的指向都会被确定. 变量对像会按顺序填充:</li></ul><ol><li>函数参数(没有就是 undefined)</li><li>函数声明(命名冲突, 会覆盖之前的)</li><li>变量声明(值为 undefined, 命名冲突, 会被忽略)</li></ol><ul><li>活动对象(也称激活对象)<br>函数调用活动对象就作为变量对象, 所以在函数调用时<code>变量对象 === 活动对象</code>, 活动对象会先包含<code>arguments</code>对象及方法.</li></ul><p>还是看个代码来说吧:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">11</span>)</span><br><span class="line"><span class="comment">// 建立阶段</span></span><br><span class="line">fooExecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">11</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">11</span>, <span class="comment">// 只有参数被赋值</span></span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;...&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">fooExecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">11</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">11</span>,</span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>', // 变量在这个时候才被赋值</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;...&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上三个概念都无法用过代码访问, 是解释器在后台使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在说声明提升之前, 首先应该了解三个概念性的东西, 执行上下文(Execution Context)/ 变量对象(Variable Object)和活动对象(Activation Object), 这三个概念是在 ES3 中出现的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行上下
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="https://yoursite.com/2017/12/10/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E5%A7%94%E6%89%98/"/>
    <id>https://yoursite.com/2017/12/10/事件代理-委托/</id>
    <published>2017-12-10T14:05:49.000Z</published>
    <updated>2022-08-23T09:37:40.691Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 和 HTML 交互是通过事件实现, 而事件处理程序订阅事件从而执行相应的操作.</p><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>事件流描述的是 从页面接收事件的顺序.<br>事件冒泡: 从最具体的元素到最不具体的元素(从内到外); — IE<br>事件捕获: 从最不具体的元素到最具体的元素(从外到内); — Netscape<br>DOM 事件流: 先捕获后冒泡的方式.</p><p>DOM事件流包括三个阶段:</p><ol><li>捕获阶段 (IE 低版本不支持该阶段)</li><li>目标阶段 (触发事件)</li><li>冒泡阶段 (回传文档)</li></ol><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p>事件是用户或浏览器自身执行的动作, 事件处理程序(事件监听器)是响应事件的动作. 比如 click 事件的事件处理程序就是 onclick, 为事件指定处理程序的方式也有几种.</p><h5 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h5><p>在标签上绑定事件处理程序, HTML 和 js 紧密耦合<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">'alert('</span><span class="attr">clicked</span>')'&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="DOM-0级事件处理程序"><a href="#DOM-0级事件处理程序" class="headerlink" title="DOM 0级事件处理程序"></a>DOM 0级事件处理程序</h5><p>将一个函数赋值给一个事件处理程序属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="DOM-2级事件处理程序"><a href="#DOM-2级事件处理程序" class="headerlink" title="DOM 2级事件处理程序"></a>DOM 2级事件处理程序</h5><p>定义了两个方法, 用于绑定事件处理程序和删除事件处理程序: <code>addEventListener()</code>和<code>removeEventListener()</code>. 所有的 DOM 节点都包含这两个方法, 方法有三个参数: 需要处理的事件名/ 处理函数/ 布尔值(true 为在捕获阶段调用; false 为在冒泡阶段调用)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="comment">// 绑定处理程序</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 移除处理程序(移除处理程序时, 第二个参数必须和绑定时一样)</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'remove'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h4 id="IE-和-DOM2级事件处理程序的区别"><a href="#IE-和-DOM2级事件处理程序的区别" class="headerlink" title="IE 和  DOM2级事件处理程序的区别"></a>IE 和  DOM2级事件处理程序的区别</h4><ul><li>IE 事件处理程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = docuemnt.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// this === window</span></span><br><span class="line">alert(<span class="string">'click on IE'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'remove on IE'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>以上两种事件处理程序都支持绑定多个事件, DOM2级按照顺序</strong></p><ul><li>跨浏览器事件处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtil = &#123;</span><br><span class="line"><span class="comment">// 绑定事件处理程序</span></span><br><span class="line">addHanlder: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">element.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">element.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 移除事件处理程序</span></span><br><span class="line">removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">element.removeEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">element.detachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="事件代理-委托"><a href="#事件代理-委托" class="headerlink" title="事件代理/ 委托"></a>事件代理/ 委托</h4><p>由于事件处理程序越多, 性能越差, 所以有了事件处理程序. 事件代理的原理是基于事件的冒泡机制实现的, 由上级节点代理完成事件绑定, 优点是: </p><blockquote><p>节省内存占用, 减少事件注册. 比如在<code>ul</code>代理所有<code>li</code>的点击事件<br>动态新增子级时, 无需再次绑定事件.</p></blockquote><p>可能会提到<code>currentTarget</code>和<code>target</code>的区别: currentTarget 是注册事件时的目标(在事件处理程序中<code>this</code>始终指向 currentTarget), target 是真正触发事件的目标.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 事件注册时的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body === event.currentTarget); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 真正点击的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(event.target === <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>事件内置的 event 对象, 下面列举常用的几个事件对象属性:</p><ul><li>event || window.event</li><li>event.preventDefault() || window.event.cancelBubble(Boolean)<br>阻止浏览器默认事件</li><li>event.stopPropagation() || window.event.returnValue(Boolean)<br>阻止冒泡事件</li><li>event.target || winow.event.srcElement</li></ul><p>Created on 2017-12-10 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 和 HTML 交互是通过事件实现, 而事件处理程序订阅事件从而执行相应的操作.&lt;/p&gt;
&lt;h4 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h4&gt;&lt;p&gt;事件流描述的是 
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flex 弹性盒子</title>
    <link href="https://yoursite.com/2017/11/23/Flex-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"/>
    <id>https://yoursite.com/2017/11/23/Flex-弹性盒子/</id>
    <published>2017-11-23T11:15:28.000Z</published>
    <updated>2022-08-23T09:37:40.688Z</updated>
    
    <content type="html"><![CDATA[<p>Flex 是 Flexible box 的缩写(弹性布局), 用来为盒模型提供最大灵活性的布局, 更为方便的实现响应式布局.</p><blockquote><p>如何使用 Flex<br>任何一个容器都可以指定为一个 Flex 布局.  </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 行内元素 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 内核为 webkit 的浏览器 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="comment">/* Safari */</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-flex;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定 Flex布局之后的子元素<code>float</code>/ <code>clear</code>/ <code>vertical-align</code>都将失效.</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>所有采用 Flex 布局的的元素都称为 Flex 容器, 它的所有资源都为 Flex 容器的容器成员, 成为 Flex 项目.<br>Flex 容器都存在两根轴: 水平的主轴(main axis)和垂直的交叉轴(cross axis), 项目默认沿主轴排列. 每个项目占主轴的空间称为<code>main size</code>, 占交叉轴的空间称为<code>cross size</code>.</p><h4 id="Flex-容器的属性"><a href="#Flex-容器的属性" class="headerlink" title="Flex 容器的属性"></a>Flex 容器的属性</h4><ul><li><p>flex-direction<br>项目排列在主轴的方向 </p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row: 默认值, 主轴为水平方向, 起点为左边</li><li>row-reverse: 主轴为水平方向, 起点为右边</li><li>column: 主轴为交叉轴方向, 起点在顶部</li><li>column-reverse: 主轴为交叉轴方向, 起点在底部</li></ul></li><li><p>flex-wrap<br>项目在主轴上的换行方式</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap: 默认值, 不换行</li><li>wrap: 换行, 第一行在上面</li><li>wrap-reverse: 换行, 第一行在下面</li></ul></li><li><p>flex-flow<br>该属性为<code>flex-direction</code>和<code>flex-wrap</code>的缩写, 默认值为<code>row nowrap</code></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-flow</span>: flex-direction || flex-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>justify-content<br>项目在主轴上的对齐方式, 所以它的对齐方式跟轴的方向有关</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-start | center | space-around | space-between | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 默认值, 左对齐</li><li>center: 居中</li><li>space-around: 左右居中对齐, 项目之间间隔为项目与边框的间隔大一倍</li><li>space-between: 两端对齐</li><li>flex-end: 右对齐 </li></ul></li><li><p>align-items<br>项目在交叉轴在的对齐方式, 与交叉轴方向有关</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">align-items</span>: flex-start | center | baseline | stretch | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 交叉轴起点对齐</li><li>center: 居中</li><li>baseline: 项目第一行文字基线对齐, 类似在文字的下划线位置</li><li>stretch: 默认值, 项目没有高度或为<code>auto</code>时, 占满整个容器</li><li>flex-end: 终点对齐</li></ul></li><li><p>align-content<br>多根轴线对齐方式. 如果项目只有一根轴线, 该属性则不起作用. 跟<code>align-items</code>容易混淆, 区别在于 <code>align-content</code>项目有多行时起作用, 而<code>align-items</code>项目单行就可起作用.</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | center | space-around | space-between | stretch | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 交叉轴对齐方式</li><li>center: 居中</li><li>space-around: 左右居中对齐</li><li>space-between: 两端对齐</li><li>stretch: 默认值, 项目轴线占满整个交叉轴</li></ul></li></ul><h4 id="Flex-项目属性"><a href="#Flex-项目属性" class="headerlink" title="Flex 项目属性"></a>Flex 项目属性</h4><ul><li><p>order<br>定义项目的排列顺序, 数值越小越靠前, 默认为0</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">order</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-grow<br>定义项目的放大比例, 默认为0(有剩余空间也不放大). 如果所有项目都为1, 它们将等分剩余空间; 如果其中一个项目为2, 其它项目为1, 那么属性为2的项目占据的剩余空间将比属性为1的项目大一倍</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-shrink<br>定义项目的缩小比例, 默认为1(如果空间不足, 将缩小). 如果所有项目都为1, 当空间不足时, 所有项目都将等比例缩小; 如果其中一个项目为0, 其它项目为1, 那么当空间不足时, 前者将不缩小</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-basis<br>定义属性在分配多余空间之前项目占据的主轴空间(main size). 浏览器会根据这个属性计算是否有多于空间. 默认值为 auto(项目本身的大小). 如果不使用<code>box-sizing</code>来改变盒模型的话, 该属性将决定项目的内容盒(content-box)的宽或者高(宽或高取决于主轴的方向).</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="comment">/* size 的单位可以为 px/ em/rem 百分比都行(负值无效) */</span></span><br><span class="line"><span class="attribute">flex-basis</span>: &lt;size&gt; | &lt;content&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size: 跟宽高设置一样, 不多说.</li><li>content: css3 的几个 width 新属性. fill-available/ max-content/ min-content/ fit-content, 兼容性 IE 不支持.</li></ul></li><li><p>flex<br>该属性为<code>flex-grow</code>/<code>flex-shrink</code>和<code>flex-basis</code>的缩写, 默认值为 <code>0 1 auto</code>, 后两个属性可选</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: none | flex-grow flex-shrink flex-basis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>align-self<br>允许单个项目与其他项目有不同的对齐方式, 可覆盖<code>align-items</code>属性, 默认值为 auto, 继承父级元素的<code>align-items</code>属性, 没有的话等同于<code>stretch</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">align-self: auto | flex-start | center | stretch | baseline | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>除了 <code>auto</code>以外其他属性值跟<code>align-items</code>一样就不再重复了.</p><blockquote><p>说一下 CSS3 width 的几个新属性<br>需要带有私有前缀  </p></blockquote><ul><li>fill-available<br>让元素自动100%得填充父级宽度, 让元素表现得像块级元素一样, <code>inline-block</code>的元素也可以自动填充, 顺便再父级加一个<code>line-height</code>让元素垂直居中.</li><li>max-content<br>它的表现就像设置了<code>white-space:nowrap</code>一样, 元素的宽度取子元素中较大宽度的宽度</li><li>min-content<br>它表示的不是子元素中宽度小的那个宽度, 而是内部元素最小宽度值最大的那个元素作为最终宽度. 比如: 一个<code>div</code>中, 有一张<code>img</code>的宽度为200px, 有一个<code>p</code>里面的文字可多可少里面有英文(如果文本全是中文, 最小宽度值就是一个中文的宽度, 如果夹杂英文, 由于英文默认不换行, 所以最小宽度值是最长单词的宽度), 所以假设这里英文的最长单词不足200px, 那么最终的元素宽度就为200px</li><li>fit-content<br>设置该属性后, 不需要固定宽度, 在父级元素<code>margin: 0 auto</code>就可以实现水平居中了</li></ul><p>Created on 2017-11-23 By Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flex 是 Flexible box 的缩写(弹性布局), 用来为盒模型提供最大灵活性的布局, 更为方便的实现响应式布局.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何使用 Flex&lt;br&gt;任何一个容器都可以指定为一个 Flex 布局.  &lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>闭包和高阶函数</title>
    <link href="https://yoursite.com/2017/10/26/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://yoursite.com/2017/10/26/闭包和高阶函数/</id>
    <published>2017-10-26T15:09:00.000Z</published>
    <updated>2022-08-23T09:37:40.693Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇笔记是为正式开始学习 javadcript 设计模式做铺垫，由于许多设计模式都用到了闭包和高阶函数来实现, 所以了解这两个知识点也是必要的.</p><blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包简单的来说是函数与函数之间的桥梁, 让一个函数有权访问另一个函数作用域里的变量. 定义说起来还是很生涩的, 要理解闭包我们需要先知道变量的作用域以及变量的生命周期才行.</p></blockquote><ul><li>变量的作用域<br>变量的作用域指的是变量的有效范围. 在函数中生命变量时, 如果没有关键字 var、let及const那么这个变量就会变成全局变量; 如果有这个时候的变量就是局部变量, 只有在函数内部才能够访问到.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">alert(a)</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br><span class="line">alert(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li></ul><p>函数这个时候就像一块单面镜, 里面可以看见外面, 外面不能看到里面. 因为函数在搜索一个变量的时候, 如果函数内没有这个变量, 那么这个搜索过程会随着代码的执行环境创建的作用域链向外搜索直至全局对象.</p><ul><li>变量生命周期<br>对于全局变量来说, 它的生命周期自然是永久的除非我们手动销毁这个变量; 对于局部变量, 一般来说当函数执行完毕之后该变量就会跟着被销毁. 而闭包则可以延续局部变量的生命周期, 举个栗子:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">a++;</span><br><span class="line">alert(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = func();</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><p>这里我们可以看到 a 变量不仅在外部可以被访问到而且还一直在递增, 这是因为 <code>fn = func()</code>执行时, fn 保存了 func 返回的匿名函数, 而这个匿名函数是有权 func() 被调用时产生的环境. a 变量就在这个环境中, 所以既然局部变量所在换的环境没有被销毁那么 a 变量也不会被销毁掉, 这个例子就产生了一个闭包结构.</p><blockquote><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4></blockquote><ul><li>封装变量<br>众所周知全局变量是非常容易引起命名冲突的, 所以我们可以利用闭包把一些不需要暴露在全局的变量封装成私有变量.</li></ul><p>假设有一个计算乘积的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mult = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 缓存(封装起来)</span></span><br><span class="line"><span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> arg = [].join.call(<span class="built_in">arguments</span>, <span class="string">','</span>)</span><br><span class="line"><span class="comment">// 封装计算方法</span></span><br><span class="line"><span class="keyword">let</span> calulate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">a = a * <span class="built_in">arguments</span>[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在缓存则不计算</span></span><br><span class="line"><span class="keyword">if</span> (arg <span class="keyword">in</span> cache) <span class="keyword">return</span> cache[arg]</span><br><span class="line"><span class="keyword">return</span> cache[arg] = calulate.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mult(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>将变量 cache 封装在 mult 函数中来缓存已经计算过的参数, 以减少重复计算. 这个缓存机制本来是可以扔在全局环境中的.</p><ul><li>延续局部变量生命周期<br>平常做埋点会用到的 image 对象来上报数据, 如下:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = src</span><br><span class="line">&#125;</span><br><span class="line">report(<span class="string">'http://xxxxx.com/xxx'</span>)</span><br></pre></td></tr></table></figure><p>这种写法会造成数据丢失, 因为在 HTTP 还未结束时, report 函数已经执行完毕而 img 为 report 函数中的局部变量, 在函数执行完毕后就会随之销毁造成数据丢失的情况. 下面用闭包把变量封装起来, 来解决这一问题:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> imgs = []</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">imgs.push(img);</span><br><span class="line">img.src = src</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line">report(<span class="string">'http://xxxxx.com/xxx'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><h4 id="闭包实现命令模式"><a href="#闭包实现命令模式" class="headerlink" title="闭包实现命令模式"></a>闭包实现命令模式</h4><p>说了这么多就来看看关于闭包的运用吧, 这里用闭包简单实现下命令模式, 顺便预先了解一下命令模式.</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'open'</span> <span class="attr">onclick</span>=<span class="string">'execute'</span>&gt;</span>执行命令<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'close'</span> <span class="attr">onclick</span>=<span class="string">'undo'</span>&gt;</span>撤销命令<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>面向对象版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TV = &#123;</span><br><span class="line">open () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is open!'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">close () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is close!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收命令</span></span><br><span class="line"><span class="keyword">const</span> ReceiveCommand = <span class="function"><span class="params">receiver</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.receiver = receiver</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开电视</span></span><br><span class="line">ReceiveCommand.prototype.execute = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.receiver.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关电视</span></span><br><span class="line">ReceiveCommand.prototype.undo = functon () &#123;</span><br><span class="line"><span class="keyword">this</span>.receiver.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置命令</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">command.execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">command.undo()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将命令告诉执行者, 设置命令传入执行者</span></span><br><span class="line">setCommand(<span class="keyword">new</span> ReceiveCommand(TV))</span><br></pre></td></tr></table></figure></li></ul><p>命令模式是把请求发起者和执行命令(执行者)分离开来, 以达到解耦的目的. 在执行命令之前, 把命令放入执行者来告诉执行者要执行什么样的命令, 命令模式大概就是这样啦.</p><ul><li>闭包版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TV = &#123;</span><br><span class="line">open () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is open!'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">close () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is close!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行者</span></span><br><span class="line"><span class="keyword">const</span> receiveCommand = <span class="function"><span class="params">receiver</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> execute = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> receiver.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> undo = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> receiver.close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">execute: execute,</span><br><span class="line">undo: undo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起者</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="params">command</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).onclick = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">execute.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).onclick = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">undo.close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setCommand(receiveCommand(TV))</span><br></pre></td></tr></table></figure></li></ul><p>闭包明显清晰更多, 也更简洁.</p><blockquote><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>将函数作为参数传递或让函数执行结果返回另一个函数, 满足这两个条件之一的函数都可以称作为高阶函数.</p></blockquote><h4 id="将函数作为参数传递"><a href="#将函数作为参数传递" class="headerlink" title="将函数作为参数传递"></a>将函数作为参数传递</h4><p>将函数作为参数传递, 就意味着我们可以将与业务相关的逻辑代码分离出来, 解除业务代码和不变逻辑的耦合, 最常见的就是我们的回调函数. 实际运用中 ajax 异步请求, 当我们不知道返回值在什么时候返回值又需要在返回后做一些处理, 就要用到回调函数了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getPersonInfo = <span class="function"><span class="keyword">function</span> (<span class="params">userId, callback</span>) </span>&#123;</span><br><span class="line">$.ajax(<span class="string">`http://xxx/getPersonInfo?<span class="subst">$&#123;userId&#125;</span>`</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">callback &amp;&amp; callback(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的匿名函数就是上面的 callback</span></span><br><span class="line">getPersonInfo(<span class="string">"54332123"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种是我们比较常见的回调函数, 在其他的方面, 也可以将一些请求委托给另一个函数代为执行, 如:<br>假如我们需要先创建100的 div 节点, 然后把它们隐藏掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count 默认值为100</span></span><br><span class="line"><span class="keyword">const</span> appendDiv = count = <span class="number">100</span>, callback =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (count &amp;&amp; <span class="keyword">typeof</span> count === <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">div.innerHTML = i</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"><span class="comment">// 将业务代码委托执行</span></span><br><span class="line">callback &amp;&amp; callback(div)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 把改变样式的业务逻辑分离出来</span></span><br><span class="line">appendDiv(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">el.style.cssText = <span class="string">`display: none`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就将业务逻辑分离出来了, 以后可能我们想改颜色啦或者位置什么的也方便维护.</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>相比把函数作为参数传递, 可能函数当做返回值返回运用场景更多一些, 让函数返回另一个可执行函数就意味着运算过程可延续.直接来看一些例子吧.</p><ul><li>检查类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Type = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, type; type = [<span class="string">'Array'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>][i++];) &#123;</span><br><span class="line">Type[<span class="string">'is'</span> + type] = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object '</span>+ type +<span class="string">']'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Type.isArray([])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Type.isString(<span class="string">'123'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Type.isNumber(<span class="number">123</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>单例模式<br>  这里先不讨论单例模式, 只看代码实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 函数作为参数传递</span></span><br><span class="line"><span class="keyword">const</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> ret;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 如果 ret 不存在, ret 等于 fn 函数</span></span><br><span class="line"><span class="keyword">return</span> ret || (ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 调用这个高阶函数</span></span><br><span class="line"><span class="keyword">let</span> getDiv = getSingle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 参数也会一起传过来, 这里返回['123']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">getDiv(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure><p>getSingle 这个高阶函数既将函数作为参数传递, 又让函数执行后返回另一个函数.</p><blockquote><p>JavaScript 设计模式与开发实践还有个例子也很有意思<br>叫做 AOP(面向切面编程), 作用是把与业务逻辑不相关的部分抽离出来再通过动态植入的方式加入业务逻辑的模块中.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原函数之前</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// A</span></span><br><span class="line"><span class="comment">// 执行新函数并修正 this</span></span><br><span class="line">beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"><span class="comment">// 执行原函数</span></span><br><span class="line"><span class="keyword">return</span> that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原函数之后</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// B</span></span><br><span class="line"><span class="comment">// 先执行 before 函数</span></span><br><span class="line">that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"><span class="comment">// 再执行新函数</span></span><br><span class="line"><span class="keyword">return</span> afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn = fn.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn() <span class="comment">// 按顺序输出 1 2 3</span></span><br></pre></td></tr></table></figure><p>上面的执行顺序是这样的:</p><ol><li>After中的回调函数 B<br>因为在最后执行 fn 函数时, fn 已经是 after 函数了, 因此在 fn() 执行时调用的是 after 中返回的匿名函数B.</li><li>B 中的 that.apply(this, arguments)<br>此时的 that 指向 before 函数</li><li>执行Before中的回调函数 A</li><li>A 中的 beforeFn.apply(this, arguments)<br>执行 console.log(1)</li><li>return that.apply(this, arguments)<br>执行 console.log(2)</li><li>回到 after 函数中执行return afterFn.apply(this, arguments)<br>执行 console.log(3)</li></ol><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>函数柯里化可以说是高阶函数经典中的经典了, 说到高阶函数应该很快就会想到他了. 我理解的函数柯里化是: 先将参数依次缓存, 在真正需要计算结果时, 才进行计算这样可以减少运算次数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用 curring</span></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> argsArr = []</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [...args].length === <span class="number">0</span></span><br><span class="line">            ? fn.apply(<span class="literal">null</span>, argsArr)</span><br><span class="line">            : [].push.apply(argsArr, [...args])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要计算的函数</span></span><br><span class="line"><span class="keyword">let</span> calculate = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> money = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...argsArr</span>) =&gt;</span> &#123;</span><br><span class="line">        argsArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            money += item</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> money</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line">calculate = curring(calculate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存参数, 其实并没有计算</span></span><br><span class="line">calculate(<span class="number">20</span>)</span><br><span class="line">calculate(<span class="number">40</span>)</span><br><span class="line">calculate(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正计算的时候</span></span><br><span class="line">calculate()</span><br></pre></td></tr></table></figure><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>在某些场景下函数有可能会被非常频繁地调用, 从而造成很大的性能问题. 例如: window.resize事件、mousemove 事件, 它们触发的频率太高了, 而用户并不需要如此高频率的使用. 因此函数节流就是为了限制函数出发的频率.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval = <span class="number">800</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>, timer</span><br><span class="line">    <span class="comment">// ...args =&gt; event</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">            fn.apply(that, [...args])</span><br><span class="line">            <span class="keyword">return</span> isFirst = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            fn.apply(that, [...args])</span><br><span class="line">        &#125;, interval)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入需要节流的函数和间隔时间</span></span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><h4 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h4><p>上面我们提供了一种限制函数调用频率的解决方案, 现在是另一个问题: 某些函数是由用户主动唤起的, 但是因为一些原因导致函数严重影响页面的性能. 分时函数可以为我们解决这个问题, 我理解的分时函数: 将请求分批处理, 在一定的时间内执行一部分请求, 直到请求全部完成.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分时函数</span></span><br><span class="line"><span class="keyword">const</span> timeChunk = <span class="function">(<span class="params">data, fn, count = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer, obj</span><br><span class="line">    <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(count, data.length); i++) &#123;</span><br><span class="line">            obj = data.shift()</span><br><span class="line">            fn.apply(<span class="literal">null</span>, obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length === <span class="number">0</span>) &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            start()</span><br><span class="line">        &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    ary.push(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分时化</span></span><br><span class="line"><span class="keyword">let</span> renderfriendList = timeChunk(ary, <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = n</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line">renderfriendList()</span><br></pre></td></tr></table></figure><h4 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h4><p>举个例子, 在 web 中为了满足各浏览器之间的差异, 我们会做一些嗅探工作. 异于常规方案, 惰性加载在真正需要时才使用且进入条件分支后在内部重写该函数, 这样重写后的函数就是我们需要的函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="comment">// 重写函数</span></span><br><span class="line">        addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">            el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">            el.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(el, type, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">addEvent(btn, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Created on 2017-10-26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇笔记是为正式开始学习 javadcript 设计模式做铺垫，由于许多设计模式都用到了闭包和高阶函数来实现, 所以了解这两个知识点也是必要的.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="JavaScript设计模式" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>base64 转 blob</title>
    <link href="https://yoursite.com/2017/10/22/base64-%E8%BD%AC-blob/"/>
    <id>https://yoursite.com/2017/10/22/base64-转-blob/</id>
    <published>2017-10-22T13:44:12.000Z</published>
    <updated>2022-08-23T09:37:40.690Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = base64.split(<span class="string">','</span>), mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">    bstr = atob(arr[<span class="number">1</span>]), n = bstr.length, u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="comment">// charCodeAt() 方法可返回指定位置的字符的 Unicode 编码</span></span><br><span class="line">        u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 'application/octet-binary' (默认值)</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;)</span><br></pre></td></tr></table></figure><h4 id="Base64-的编码码和解码"><a href="#Base64-的编码码和解码" class="headerlink" title="Base64 的编码码和解码"></a>Base64 的编码码和解码</h4><p>使用atob 和 btoa 方法.</p><ul><li>atob() 解码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atob(<span class="string">"amF2YXNjcmlwdA=="</span>)</span><br><span class="line"><span class="comment">// 解码结果 "javascript"</span></span><br></pre></td></tr></table></figure><ul><li>btoa() 编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(javascript)</span><br><span class="line"><span class="comment">// 转码结果 "amF2YXNjcmlwdA=="</span></span><br></pre></td></tr></table></figure><p>以上两种方法对于中文是有局限性的, 解决如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"China，中国"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先用 encodeURI() 编码</span></span><br><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">window</span>.encodeURIComponent(str))</span><br><span class="line"><span class="comment">// "Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ="</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// atob 解码 Base64 再用 decodeURI() 解码</span></span><br><span class="line"><span class="built_in">window</span>.decodeURIComponent(<span class="built_in">window</span>.atob(<span class="string">'Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ='</span>))</span><br><span class="line"><span class="comment">// "China，中国"</span></span><br></pre></td></tr></table></figure><p>Created on 2017-9-4 by Cara*</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>盒模型</title>
    <link href="https://yoursite.com/2017/10/21/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yoursite.com/2017/10/21/盒模型/</id>
    <published>2017-10-21T15:58:06.000Z</published>
    <updated>2022-08-23T09:37:40.692Z</updated>
    
    <content type="html"><![CDATA[<p><code>CSS</code> 盒模型 (Box Model), 包含的要素分别为: content/padding/border/margin.</p><h3 id="标准盒模型-amp-怪异盒模型"><a href="#标准盒模型-amp-怪异盒模型" class="headerlink" title="标准盒模型 &amp; 怪异盒模型"></a>标准盒模型 &amp; 怪异盒模型</h3><p>盒模型分为W3C的标准盒模型和IE的标准盒模型.</p><ul><li><p>标准盒模型<br><code>content + padding+ border + margin</code>  标准盒模型的 content 是不包含其他部分的, 如下图:<br><img src="http://orf90agxq.bkt.clouddn.com/GitHub/boxW3C_BOX.jpeg" alt="W3C-BOX"></p></li><li><p>IE标准盒模型<br><code>content(padding + border) + margin</code> 而IE标准盒模型的 content 已经包含padding和border的值, 如下图:<br><img src="http://orf90agxq.bkt.clouddn.com/GitHub/boxIE_BOX.jpeg" alt="IE-BOX"></p></li></ul><p>在文档顶部声明 <code>DOCTYPE</code> 就是为了让浏览器使用 W3C标准盒模型, 但是在 IE5/ IE6 下依然是 IE 标准盒模型. 当然通过<code>box-sizing</code>属性可以在两者之间转换.</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>两个垂直方向相邻的块级元素相遇时, 外边距会合并且取值两者较大值的 <code>margin</code> 作为外边距.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方案:</span><br><span class="line"> *&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>margin 出轨…<br>当父元素没有 <code>border</code> 边框时, 第一个子元素添加 <code>margin-top</code> 会超出父元素, 相同最后一个子元素添加 <code>margin-bottom</code> 也同样会超出父元素, 如下图: </p></li></ol><ul><li><p>第一个子元素添加 margin-top<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelmargin.png" alt="marginTop"></p></li><li><p>最后一个子元素添加 margin-bottom<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelmarginBottom.png" alt="marginBottom"></p></li><li><p>前两者同时存在时, 父元素添加 border<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelborder.png" alt="marginBottom"></p></li></ul><p>解决方案有四种: </p><blockquote><ol><li>给父元素添加 border.</li></ol></blockquote><blockquote><ol start="2"><li>给父元素添加 padding.</li></ol></blockquote><blockquote><ol start="3"><li>给父元素添加 overflow: hidden.</li></ol></blockquote><blockquote><ol start="4"><li>给父元素添加伪类. (最佳)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>Created on 2017-8-15 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;CSS&lt;/code&gt; 盒模型 (Box Model), 包含的要素分别为: content/padding/border/margin.&lt;/p&gt;
&lt;h3 id=&quot;标准盒模型-amp-怪异盒模型&quot;&gt;&lt;a href=&quot;#标准盒模型-amp-怪异盒模型&quot; class=
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>位运算符</title>
    <link href="https://yoursite.com/2017/10/18/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://yoursite.com/2017/10/18/位运算符/</id>
    <published>2017-10-18T15:06:59.000Z</published>
    <updated>2022-08-23T09:37:40.691Z</updated>
    
    <content type="html"><![CDATA[<p>在C或者其他语言数值的运算其实都是先将数值转换为二进制在做运算的,<br>而位运算符就是直接进行二进制运算, 因此速度会非常快. 但是对于JavaScript<br>来说, 执行环境一般接触不到硬件, 所以性能完全不能和其他语言相比. 不过作为<br>了解还是需要的, 只对较为常见的位运算符作记录.</p><h3 id="位运算-NOT"><a href="#位运算-NOT" class="headerlink" title="位运算 NOT"></a>位运算 NOT</h3><p>位运算 NOT 由 ( ~ ) 符号表示, 其实就是对数值求负之后再减一, 如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = ~num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~num 效果同下</span></span><br><span class="line">num2 = -num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// -11</span></span><br></pre></td></tr></table></figure><h3 id="左位移运算"><a href="#左位移运算" class="headerlink" title="左位移运算"></a>左位移运算</h3><p>左位移运算由 ( &lt;&lt; ) 符号表示. 将数值的所有位向左移动指定数量.例如:<br>左移一位乘2, 左移2位乘4, 以此类推.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果同下</span></span><br><span class="line"> num2 = num * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="有符号右移运算"><a href="#有符号右移运算" class="headerlink" title="有符号右移运算"></a>有符号右移运算</h3><p>有符号右移运算符由 ( &gt;&gt; ) 符号表示, 将数值的所有为向右移动指定位数,<br>同时保留该数的符号 (正号或者负号) . 有符号右移运算符跟左位移运算符正好<br>相反.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果同下</span></span><br><span class="line">num2 = num / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="无符号右位移运算符"><a href="#无符号右位移运算符" class="headerlink" title="无符号右位移运算符"></a>无符号右位移运算符</h3><p>无符号运算符由 ( &gt;&gt;&gt; ) 符号表示, 对于正数无符号右位移运算符跟无符号右位移<br>运算符规则相同; 负数时会出现无限大的数值, 所以决定使用无符号右位移运算符<br>时一定要小心.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C或者其他语言数值的运算其实都是先将数值转换为二进制在做运算的,&lt;br&gt;而位运算符就是直接进行二进制运算, 因此速度会非常快. 但是对于JavaScript&lt;br&gt;来说, 执行环境一般接触不到硬件, 所以性能完全不能和其他语言相比. 不过作为&lt;br&gt;了解还是需要的, 只对
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this/ call and apply</title>
    <link href="https://yoursite.com/2017/10/17/this-call-and-apply/"/>
    <id>https://yoursite.com/2017/10/17/this-call-and-apply/</id>
    <published>2017-10-17T15:01:38.000Z</published>
    <updated>2022-08-23T09:37:40.691Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中, <code>this</code>关键字很容易使大家疑惑, 再加上 <code>Function.prototype.call</code>和<code>Function.prototype.apply</code>这两个方法的广泛运用, 所以很有必要弄清<code>this</code>的使用.</p><blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>首先先说一下<code>this</code>的概念: <code>this</code>总是指向一个对象, 而这个对象具体是谁, 是根据运行时的函数执行的环境动态绑定的, 而非函数被声明时的环境. 当然到现在箭头函数的出现, <code>this</code>对不了解的同学们来说, 无疑是添了一把乱… 接下来我们一个一个的来说吧.</p></blockquote><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1. this的指向"></a>1. <code>this</code>的指向</h4><p>我们除开不常用的 with 和 eval 的情况, 具体到实际应用中, <code>this</code>的指向大致可以分为以下四种情况.</p><ul><li>作为对象的方法被调用</li><li>作为普通函数被调用</li><li>构造器调用</li><li><p>被 call 和 apply 方法调用<br>下面来用 &lt; JavaScript 设计模式 &gt; 中的例子说明这四种情况.</p><ol><li><p>作为对象方法调用<br>当函数作为对象的方法被调用时, <code>this</code>指向该对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'cara'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName() <span class="comment">// true 'cara'</span></span><br></pre></td></tr></table></figure></li><li><p>作为普通函数调用<br>当函数不作为对象的方法被调用时, 也就是我们平常说的普通函数的方式, 此时的<code>this</code>总是指向全局对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName()) <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 obj 的 getName方法赋值给了一个变量</span></span><br><span class="line"><span class="comment">// 调用的时候就只会作为一个普通函数调用</span></span><br><span class="line"><span class="keyword">let</span> getName = obj.gatName;</span><br><span class="line"><span class="built_in">console</span>.log(getName()) <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>上面这中作为普通函数调用的方式常常会带来一些困扰, 比如在某个 div 节点的事件函数中, 定义了一个局部的 callback 方法. 而这个 callback 方法我们往往是想让它的 <code>this</code>指向 div 节点, 但它内部却指向<code>window</code>. 如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'div1'</span>&gt;</span>我是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.id = <span class="string">'window'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'div1'</span></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'window'</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback() <span class="comment">// 作为普通函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决以上问题其实也很简单, 如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.id = <span class="string">'window'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 用一个变量来储存节点的引用</span></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.id); <span class="comment">// 'div1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback() <span class="comment">// 作为普通函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器调用<br>先说说构造器吧, js 中没有类的概念, 但是可以从构造器中创建对象, 同时提供 <code>new</code> 运算符, 让构造器看起来更像一个类. Js 中大部分函数都可以当做构造器来使用, 所以它的外表看起来跟普通函数一样, 区别在于被调用的方式. 当用 <code>new</code> 运算符调用时, 该函数会返回一个对象. 通常情况下, 构造器里的 <code>this</code> 就指向返回的这个对象, 如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myobj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cara'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Myobj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 'cara'</span></span><br></pre></td></tr></table></figure><p>但是使用 <code>new</code>调用构造器时, 要注意一个问题. 如果构造器显式地返回了一个对象, 那么最终就会返回这个对象, 而不是我们的期望的 <code>this</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myobj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cara'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'somebody'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Myobj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 'somebody'</span></span><br></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据或是返回一个非对象类型的数据, 就不会出现上述情况</p></li><li><p>call 或 apply 方法调用<br>跟普通的函数调用相比, 用 call 或者 apply 方法调用可以动态地改变传入函数的 <code>this</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'cara'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'ben'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 'cara'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name.call(obj2)); <span class="comment">// 'ben'</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法能够很好的体现 js 的函数式语言特性. 在 js 中几乎每一次编写函数式语言风格的代码都离不开 call 和 apply.</p></li></ol></li></ul><h4 id="2-丢失的-this"><a href="#2-丢失的-this" class="headerlink" title="2. 丢失的 this"></a>2. 丢失的 this</h4><p>这是一个经常遇到的问题, 在刚刚开始学习 js 时,<code>this</code>的指向常常令我疑惑, 尤其是看到网上关于<code>this</code>指向的题目, 简直云里雾里. 下面就来看一些例子吧!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'apple'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// 'apple'</span></span><br><span class="line"><span class="keyword">let</span> getMyName = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getMyName()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面这个例子好理解, 就是通过一个变量来引用<code>obj.getName</code>方法, 并且调用 getMyName 时, 就是用的普通函数调用方式, <code>this</code>是指向全局 window 的.</p><pre><code>接下来再来看一个稍微复杂一点的例子吧:</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">    showName1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    showName2: <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name),</span><br><span class="line">    showName3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    showName4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person2 = &#123;<span class="attr">name</span>: <span class="string">'person2'</span>&#125;;</span><br><span class="line"></span><br><span class="line">person.showName1();</span><br><span class="line">person.showName1().call(person2);</span><br><span class="line"></span><br><span class="line">person.showName2();</span><br><span class="line">person.showName2().call(person2);</span><br><span class="line"></span><br><span class="line">person.showName3()();</span><br><span class="line">person.showName3().call(person2);</span><br><span class="line">person.showName3.call(person2)();</span><br><span class="line"></span><br><span class="line">person.showName4()();</span><br><span class="line">person.showName4().call(person2);</span><br><span class="line">person.showName4.call(person2)();</span><br></pre></td></tr></table></figure><p>这个例子可能大家已经很眼熟了, 不过当时我第一次做的时候几乎错了一大半😒…. 现在再拿出来看看其实还是很经典的: 在 person 和 person2 之间疯狂玩 showName 方法. 在给出答案之前我们先看看箭头函数的一些特点:</p><ul><li>箭头函数不可用作构造函数.</li><li>不可以使用 <code>arguments</code>对象, 如果要用可以使用 rest 参数代替.</li><li>不能使用<code>yield</code>命令, 所以箭头函数也不能作为 Generator 函数.</li><li><p>箭头函数的<code>this</code>是定义时所在的对象, 而不是执行时所在的对象.</p><p>  在最后一点的<code>this</code>指向上, 我个人觉得有点误导(也可能是我没理解到位)… 因为如果在对象字面量中的方法是通过箭头函数定义的话, <code>this</code>的指向就会和你期望的不一样了. </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">obj.getName(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>所以我觉得关于理解箭头函数<code>this</code>在定义时所在的对象是这样: <code>this</code>继承自父级的执行上下文(简单对象即非函数, 是没有执行上下文的), 所以上面例子就是 getName 方法的父级是 obj, 而 obj 的执行上下文是<code>window</code>, 因此输出全局对象的 name. 理解了关于箭头函数<code>this</code>的指向, 现在再来看看答案吧:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person.showName1(); <span class="comment">// 'person'</span></span><br><span class="line">person.showName1().call(person2); <span class="comment">//  'person2'</span></span><br><span class="line"></span><br><span class="line">person.showName2(); <span class="comment">// 'window'</span></span><br><span class="line">person.showName2().call(person2); <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line">person.showName3()(); <span class="comment">// 'window'</span></span><br><span class="line">person.showName3().call(person2); <span class="comment">// 'person2'</span></span><br><span class="line">person.showName3.call(person2)(); <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line">person.showName4()(); <span class="comment">// 'person'</span></span><br><span class="line">person.showName4().call(person2); <span class="comment">// 'person'</span></span><br><span class="line">person.showName4.call(person2)(); <span class="comment">// 'perons2'</span></span><br></pre></td></tr></table></figure><p>然后来分析一下答案吧:</p><ul><li><p>调用 showName1()<br>这两个方式好理解, 第一种是通过 person 对象来调用的 showName1 方法, 也就是上面我们说过的<strong>作为对象的方法被调用</strong>, 所以<code>this</code>自然指向的是person 对象; 第二种是<strong>被 call 和 apply 方法调用</strong>, 所以<code>this</code>指向的是被 call 方法矫正的 person2.</p></li><li><p>调用 showName2()<br>showName2 方法是一个箭头函数, 根据我们之前说过的箭头函数指向问题来看. 第一种通过 person 对象来调用, 由于 person 是一个简单对象所以这里它的执行上下文就是<code>window</code>, 那么就是作为普通函数调用, <code>this</code>指向 <code>window</code>; 第二种跟第一种是相同的调用方式, 只是把 person 对象换为 person2.</p></li><li><p>调用 showName3()<br>Person.showName3 是一个高阶函数, 返回了一个匿名函数. 第一种方式相当于直接调用那个匿名函数执行环境就是<code>window</code>, 所以<code>this</code>指向<code>window</code>; 第二种方式通过 person2 来调用 person 的高阶函数, 输出 person2; 第三种先通过 person2 调用 person 的高阶函数, 然后在全局作用域下执行, 因此<code>this</code>指向<code>window</code>.</p></li><li><p>调用 showName4()<br>最后这三组调用也是高阶函数, 不过返回的匿名函数用的箭头函数. 前两种方式也就印证了我们之前所说的<strong>箭头函数的 this 继承自父级执行上下文</strong>, 所以前两种都输出 person, 就算第二种方式后面用 call 方法来矫正也是不行的; 第三种也就是通过 person2 来调用执行的 showName4 方法, 自然也就输出 person2 啦.</p></li></ul><blockquote><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h3><p>Function.prototype.call() 和 Function.prototype.apply() 都是非常常用的方法, 在实际开发中和 JavaScript 的设计模式中这两个方法应用广泛. 其实它们的作用是一样的, 只是有传入参数形式不同的区别.</p></blockquote><ul><li><p>apply<br>apply 方法接收两个参数: 第一个参数指定函数体中 <code>this</code>的指向; 第二个参数为一个带下标的合集(可以是数组或者类数组), 这个参数将会传递给被调用的函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个参数为 null 的话, 表示不改变 this 的指向</span></span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>call<br>call 方法的第一个参数和 apply 方法一样, 指定<code>this</code>的指向; 第二个参数不同, call 方法的第二个参数的数量不固定, 从第二参数开始一次按顺序传递给被调用的函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><p>在我们不关心具体有多少参数被传入函数时, 就可以使用 apply 方法一股脑推过去就行了; 当我们明确的知道有多少参数, 想一目了然的表达形参和实参的对应关系时, 那么就可以用 call 方法.</p><ul><li><p>借用其他对象的方法<br>call 和 apply 经常被用来借用其他对象的方法, 常用的就有借用<code>Array</code>的方法来操作<code>arguments</code>或者借用构造函数来实现一些类似继承的效果.</p><ol><li><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 借用构造函数 A</span></span><br><span class="line"><span class="keyword">let</span> B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;;</span><br><span class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">'cara'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.getName); <span class="comment">// 'cara'</span></span><br></pre></td></tr></table></figure></li><li><p>借用 Array 的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// &#123;'0': 1, '1': 2, '2': 3&#125;</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>借用的时候要保证两个必要条件: 1. 对象本身要可以存取属性; 2. 对象的 length 属性可读写.</p><blockquote><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>绑定函数 bind 也是可以用作矫正 <code>this</code>的指向, bind 函数会创建一个新的函数(绑定函数), 新函数和目标函数将拥有相同的函数体. 第一个参数绑定<code>this</code>的指向, 从第二参数起后面的参数将作为实参绑定到目标函数的形参.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> result = sum.bind(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 1 将作为实参传入 sum</span></span><br><span class="line"><span class="built_in">console</span>.log(result(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>另外当 bind 返回的函数作为构造函数使用的话, 绑定的<code>this</code>将被忽略, 实参传入目标函数.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + x</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> (original.bind(obj, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(newObj.a); <span class="comment">// 1 =&gt; this 的指向被忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b()); <span class="comment">// 3 =&gt; 2 被传入 original</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法都是改变<code>this</code>指向后立即执行而 bind 可以在你想执行的<br>时候再执行.</p><p>差不多就到这儿吧, 要是有补充再接着写…</p><p>Created on 2017-10-17 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JavaScript 中, &lt;code&gt;this&lt;/code&gt;关键字很容易使大家疑惑, 再加上 &lt;code&gt;Function.prototype.call&lt;/code&gt;和&lt;code&gt;Function.prototype.apply&lt;/code&gt;这两个方法的广泛运用, 所
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="JavaScript设计模式" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 关于运算的小技巧</title>
    <link href="https://yoursite.com/2017/10/17/JavaScript-%E5%85%B3%E4%BA%8E%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://yoursite.com/2017/10/17/JavaScript-关于运算的小技巧/</id>
    <published>2017-10-17T14:10:33.000Z</published>
    <updated>2022-08-23T09:37:40.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-使用-操作符转换布尔值"><a href="#1-使用-操作符转换布尔值" class="headerlink" title="1. 使用 !! 操作符转换布尔值"></a>1. 使用 <code>!!</code> 操作符转换布尔值</h4><p>用于检查一个变量是否存在或者是有效值, 对变量使用 <code>!!variable</code> 来验证,<br>只要变量的值为: 0, null, undefined, NaN都将返回 false, 反之返回 true. 如: </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> ( count ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cash = count;</span><br><span class="line">        <span class="keyword">this</span>.myCash = !!count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> emptyFoo = <span class="keyword">new</span> Foo(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.cash); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myCash); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.cash); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myCash); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="2-使用-将字符串转换为数字"><a href="#2-使用-将字符串转换为数字" class="headerlink" title="2. 使用 + 将字符串转换为数字"></a>2. 使用 <code>+</code> 将字符串转换为数字</h4><p>只适合将字符串数据转换为数字, 给后台传数据的时候经常用到,<br>如果不是字符串数据会返回 NaN.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toNumber = <span class="function"><span class="params">strNumber</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> +strNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( toNumber(<span class="string">"123"</span>) ); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log( toNumber(<span class="string">" abc"</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date也可以使用</span></span><br><span class="line"><span class="built_in">console</span>.log( +<span class="keyword">new</span> <span class="built_in">Date</span>() ); <span class="comment">// 返回时间戳</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="3-并符条件"><a href="#3-并符条件" class="headerlink" title="3. 并符条件"></a>3. 并符条件</h4><p>经常用到这样的条件判断.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isConcat) &#123;</span><br><span class="line">    Login()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简写成这样 <code>isConact &amp;&amp; Login()</code></p><h3 id="4-获取数组中的最后一个元素"><a href="#4-获取数组中的最后一个元素" class="headerlink" title="4. 获取数组中的最后一个元素"></a>4. 获取数组中的最后一个元素</h3><p><code>Array.prototype.slice (begin, end)</code> 经常用这样的方式来截取数组的元素,<br>如果不设置 end 的值, 那么默认会将数组的长度作为 end 值.<br>如果将负数作为参数的 begin 值, 就可以获取数组的最后一个元素.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log( arr.slice(<span class="number">-1</span>) ); <span class="comment">// [5]</span></span><br><span class="line">conosle.log( arr.slice(<span class="number">-2</span>) ); <span class="comment">// [4,5]</span></span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><blockquote><h4 id="5-截断数组"><a href="#5-截断数组" class="headerlink" title="5. 截断数组"></a>5. 截断数组</h4><p>用来锁定数组的长度, 删除数组中的一些元素. 比如数组一共有10个元素,<br>但我只需要前5个元素, 就可以通过 <code>array.length = 5</code> 来截断数组, 如: </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log( arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log( arr.length ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log( arr ); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="6-将NodeList转换为数组"><a href="#6-将NodeList转换为数组" class="headerlink" title="6. 将NodeList转换为数组"></a>6. 将NodeList转换为数组</h4><p>如果通过 <code>doucment.querySelectorAll(&#39;p&#39;)</code> 获取元素, 它返回的是一个DOM元素的<br>数组 ( NodeList ) 对象, 但是这个数组不具有数组的功能,<br>比如 <code>push() / sort()</code> 等. 这就需要将这个 NodeList 转换为真正的数组.<br>可以使用 <code>[].slice.call( NodeList )</code> 来实现. 如:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.querySelectorAll( <span class="string">'p'</span> );</span><br><span class="line">[].slice.call( els );</span><br><span class="line">OR:</span><br><span class="line"><span class="keyword">var</span> arrElement = <span class="built_in">Array</span>.from( els );</span><br><span class="line">ES6:</span><br><span class="line"><span class="keyword">var</span> arr = [...els]</span><br></pre></td></tr></table></figure><blockquote><h4 id="7-数组元素重排"><a href="#7-数组元素重排" class="headerlink" title="7. 数组元素重排"></a>7. 数组元素重排</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(list.sort(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">Math</span>.random() - <span class="number">0.5</span>&#125;))</span><br></pre></td></tr></table></figure></blockquote><p>Created on 2017-6-14 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-使用-操作符转换布尔值&quot;&gt;&lt;a href=&quot;#1-使用-操作符转换布尔值&quot; class=&quot;headerlink&quot; title=&quot;1. 使用 !! 操作符转换布尔值&quot;&gt;&lt;/a&gt;1. 使用 &lt;code&gt;!!&lt;/code&gt; 操作符转换布尔值
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title> JavaScript 模块化</title>
    <link href="https://yoursite.com/2017/10/17/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://yoursite.com/2017/10/17/JavaScript-模块化/</id>
    <published>2017-10-17T13:49:59.000Z</published>
    <updated>2022-08-23T09:37:40.689Z</updated>
    
    <content type="html"><![CDATA[<p>使用函数和闭包来构造模块. 模块是一个提供接口却隐藏状态与现实的函数或对象.<br>通过模块可以摒弃全局变量的使用, 模块模式的一般形式是: 一个定义私有变量和函数的函数;<br>利用闭包创建可以访问私有变量和函数的特权函数.<br>—— &lt;&lt; JavaScript语言精粹 &gt;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serial_maker = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 私有变量</span></span><br><span class="line"><span class="keyword">let</span> prefix = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="comment">// 特权方法</span></span><br><span class="line">set_prefix: <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">prefix = <span class="built_in">String</span>(str);</span><br><span class="line">&#125;,</span><br><span class="line">set_num: <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">num = +n;</span><br><span class="line">&#125;,</span><br><span class="line">get_sum: <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> result = prefix + num;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seqer = serial_maker();</span><br><span class="line">seqer.set_prefix(<span class="string">'Hi'</span>);</span><br><span class="line">seqer.set_num(<span class="number">0101</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(seqer.get_sum()) <span class="comment">// 'Hi0101'</span></span><br></pre></td></tr></table></figure><h3 id="CommonJs-与-AMD"><a href="#CommonJs-与-AMD" class="headerlink" title="CommonJs 与 AMD"></a>CommonJs 与 AMD</h3><p>因为有了模块的概念, 所以我们能将很多重复性的代码封装成一个模块, 想用什么<br>功能就加载什么模块, 也能更方便是使用别人的代码. 但是这样就会要求大家都用<br>同样的方式封装模块, 所以就有了 CommonJs 和 AMD 来规范大家的写法.</p><ul><li>CommonJs<br>Node.js的模块就是参照 CommonJs 来实现的, 在服务器端是一定会用到模块的. CommonJs<br>是同步加载, 也就是说当引入一个模块必须等待该模块加载完成之后, 才会执行接下来的代码.<br>对于服务器来说所有的模块都放在本地, 所以等待的时间很短; 但对于浏览器来说, 所有的模块<br>都放在服务器, 所以等待的时间完全取决于网速, 就很容易出现假死的状态.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line"></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>AMD<br>AMD是”Asynchronous Module Definition”的缩写, 意思就是”异步模块定义”. 它就是采用异步<br>加载, 因此模块的加载并不影响后面的语句执行. 将所有依赖于这个模块的语句都放在一个定义的回调<br>函数中执行, 这样等待模块加载完成之后就会去执行这个回调函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'module'</span>], <span class="built_in">module</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">module</span>.increment(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="export-export-default"><a href="#export-export-default" class="headerlink" title="export / export default"></a>export / export default</h3><p>在JavaScript ES6中，export与export default均可用于导出常量/函数/文件/模块等,<br>以便在其它文件或模块中通过import将其导入使用.</p><ul><li>export<br>export 可以导出多个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="params">n</span> =&gt;</span> n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 index.html 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, fn&#125; <span class="keyword">from</span> <span class="string">'types.js'</span></span><br></pre></td></tr></table></figure><ul><li>export default<br>只能导出一个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 index.html 引入</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'types.js'</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> foo&#125; <span class="keyword">from</span> <span class="string">'types.js'</span></span><br></pre></td></tr></table></figure><p>Created on 2017-9-15 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用函数和闭包来构造模块. 模块是一个提供接口却隐藏状态与现实的函数或对象.&lt;br&gt;通过模块可以摒弃全局变量的使用, 模块模式的一般形式是: 一个定义私有变量和函数的函数;&lt;br&gt;利用闭包创建可以访问私有变量和函数的特权函数.&lt;br&gt;—— &amp;lt;&amp;lt; JavaScri
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Quick Sort</title>
    <link href="https://yoursite.com/2017/10/17/Quick-Sort/"/>
    <id>https://yoursite.com/2017/10/17/Quick-Sort/</id>
    <published>2017-10-17T13:42:33.000Z</published>
    <updated>2022-08-23T09:37:40.690Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的实现, 参考资料<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">阮一峰</a></p><blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快排法的思想， 分为以下三步</p><ol><li>在数据集中， 选择任意一个数据作为参照物（一般取中间位置的元素）。</li><li>所有小于参照物的元素都放在左边，大于参照物的元素都放在右边。</li><li>对左右两边的子集递归， 至到排序完成。</li></ol></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li><p>非原地快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">11</span>, <span class="number">65</span>, <span class="number">23</span>, <span class="number">108</span>, <span class="number">99</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">100</span>, <span class="number">108</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'快排'</span>);</span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 数组只剩一个元素时停止</span></span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="comment">// 取参照物</span></span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>),</span><br><span class="line">        <span class="comment">// 这里用splice删除参照物避免重复循环</span></span><br><span class="line">        pivot = array.splice(pivotIndex, <span class="number">1</span>),</span><br><span class="line">        leftArr = [],</span><br><span class="line">        rightArr = [];</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">            leftArr.push(array[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightArr.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(leftArr).concat(pivot, quickSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(array)); <span class="comment">// [ 11, 11, 11, 23, 33, 55, 65, 99, 100, 100, 108, 108 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'快排'</span>); <span class="comment">// 4ms 左右</span></span><br></pre></td></tr></table></figure></li><li><p>原地快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'快排2'</span>);</span><br><span class="line"><span class="comment">// 互换</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">items, firstIndex, secondIndex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = items[firstIndex];</span><br><span class="line">    items[firstIndex] = items[secondIndex];</span><br><span class="line">    items[secondIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">items, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = items[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)],</span><br><span class="line">        i = left,</span><br><span class="line">        j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (items[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (items[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;   </span><br><span class="line">            swap(items, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">const</span> quickSortTwo = <span class="function">(<span class="params">items, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">if</span> (items.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">"number"</span> ? <span class="number">0</span> : left;</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">"number"</span> ? items.length - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">        index = partition(items, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            quickSortTwo(items, left, index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">            quickSortTwo(items, index, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSortTwo(array));</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'快排2'</span>);</span><br></pre></td></tr></table></figure></li><li><p>原生sort</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'原生'</span>);</span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">// 5ms 左右</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'原生'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>三种方法， 当数组达到1W时差距就比较大了，原生需要17ms左右，原地快排需要13ms左右，而非原地快排则需要88ms左右。</p><p>Created on 2017-9-7 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快速排序的实现, 参考资料&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
